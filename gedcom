#!/usr/bin/env perl

# gedcom - produce data from a gedcom file

# Author Nigel Horne: njh@bandsman.co.uk
# Copyright (C) 2015-2020, Nigel Horne

# Usage is subject to licence terms.
# The licence terms of this software are as follows:
# Personal single user, single computer use: GPL2
# All other users (including Commercial, Charity, Educational, Government)
#	must apply in writing for a licence for use from Nigel Horne at the
#	above e-mail.

# FIXME: -a Goes through the entire file once for each day without remembering
#	anything
# TODO: add option to print in generations order rather than date order.
# TODO: write a post-processor to sort errors by type
# TODO: note if a child was orphaned by both parents dying before they were 16
# TODO: -i only creates a calendar for birthdays for the moment, add others
# TODO: look at census records to note the different places that a person's children
#	were born and note if the residences of the person don't include those places
# TODO: add an option for -Aw to create output as a CSV

use strict;
use warnings;
use utf8;

no lib '.';

my @modules;

# Install Pre-requisites
BEGIN {
	@modules = (
		'Geo::Coder::List 0.26', 'Gedcom', 'Genealogy::Gedcom::Date',
		'Date::Parse', 'Geo::Coder::Free 0.11', 'IPC::System::Simple',
		'Geo::Coder::Free::Local',
		'Geo::Coder::Ovi', 'CHI', 'String::Compare', 'Unicode::Diacritic::Strip',
		'Geo::Coder::RandMcnally', 'Geo::Coder::US::Census',
		'Geo::Coder::OSM', 'Geo::Coder::XYZ', 'LWP::UserAgent::Cached',
		'Geo::Coder::CA', 'Geo::Coder::Postcodes',
		'Geo::Coder::OpenCage', 'Lingua::EN::NameCase',
		'Lingua::EN::Numbers::Ordinate', 'Lingua::EN::ABC',
		'Lingua::EN::Inflect', 'DateTime::Locale', 'DateTime::Format::Natural',
		'Locale::AU', 'Locale::CA', 'Locale::US',
		'DateTime::Format::Genealogy', 'URI::Find::Schemeless',
		'Sort::Key::DateTime', 'Text::Names::GB',
		'HTTP::Cache::Transparent', 'Geo::Coder::DataScienceToolkit',
		'Class::Simple::Cached', 'Class::Simple::Readonly::Cached',
		'Net::OAuth', 'Geo::Coder::GooglePlaces', 'Geo::Coder::Bing',
		# 'Geo-Coder-PlaceFinder-0.1.tar.gz'
		'Geo::GeoNames', 'Getopt::Std', 'File::Basename',
		'LWP::UserAgent::Throttled', 'Term::ANSIColor',
		'Locale::Object::Country',
	);

	my @needfull;
	foreach my $module(@modules) {
		eval "use $module";
		if($@) {
			push @needfull, $module;
		}
	}
	# Fix for this module not being found
	eval 'use Geo::Coder::PlaceFinder';
	if($@) {
		push @needfull, 'F/FR/FRIFFIN/Geo-Coder-PlaceFinder-0.1.tar.gz'
	}

	if(scalar(@needfull)) {
		my $list = join(' ', @needfull);
		print "Installing $list\n";
		system("cpan -i $list");
	}

	# FIXME
	$SIG{__WARN__} = sub {
		my $warning = shift;
		if(($warning !~ /Subroutine Geo::Coder::OpenCage::ua redefined at/) &&
		   ($warning !~ /Subroutine HTML::GoogleMaps::V3::_text_to_point redefined at/) &&
		   ($warning !~ /Subroutine Gedcom::Individual::relationship redefined at/)) {
			if($warning =~ /^Use of uninitialized value/) {
				die $warning;
			}
			warn $warning;
		}
	};
}

foreach my $module(@modules) {
	my $version;
	if($module =~ /(.+)\s(.+)$/) {
		$module = $1;
		$version = $2;
	}
	if($module =~ /.+\/(.+)/) {
		$module = $1;
	}
	eval "require $module";
	if($@) {
		die $@;
	}
	$module->import();
	# if($version && ($module::VERSION < $version)) {
		# die "$module: need $version got ", $module::VERSIOn;
	# }
}

# use IPC::System::Simple;
use autodie qw(:all);
# use diagnostics;
# use warnings::unused;

my %opts;
getopts('aAbB:cCdDfFGgh:Hi:m:lLp:sStTwWxvy:', \%opts);
die "Usage: $0 [ -a ] [ -A ] [ -b ] [ -B book.pdf ] [ -c ] [ -C ] [ -d ] [ -D ] [ -f ] [ -F ] [ -G ] [ -h home-person-name ] [ -H [ -L ] [ -i ics_file ] [ -m month ] [ -y year ] ] [ -l ] [ -p person-to-print ] [ -s ] [ -S ] [ -t ] [ -T ] [ -w [ -W ] [ -g | -x ]] filename [ filename2 ]\n" unless($ARGV[0]);

my $me;
my @myancestors;
my @mydescendents;
my %warned;
my %printed;
my %places;
my %all_locations;
my %all_places;
my $pi = atan2(1,1) * 4;

binmode(STDOUT, ':utf8');

my $ged = Gedcom->new(gedcom_file => $ARGV[0], read_only => 1);
my $nameparser = Lingua::EN::NameParse->new(extended_titles => 1, initials => 1);
if($opts{h}) {
	my @rc = $ged->get_individual($opts{h});
	if(scalar(@rc) == 0) {
		die "$0: Can't find '$opts{h}' in $ARGV[0]";
	} elsif(scalar(@rc) == 1) {
		$me = $rc[0];
	} elsif(!$opts{'x'}) {
		# Need top of family tree
		@rc = map { ($_->father() || $_->mother()) ? () : $_ } @rc;
		if(scalar(@rc) > 1) {
			my $i = 0;
			print join("\n", map { $i++; "$i: " . $_->as_string({ include_years => 1, middle_names => 1 }) } @rc),
				"\nMore than one $opts{h} found - choose a line number: ";
			$i = <STDIN>;
			chomp $i;
			$me = $rc[$i - 1];
		} else {
			$me = $rc[0];
		}
		die 'Incorrect line number' unless($me);
	}
}

if($opts{'f'}) {
	$opts{'w'} = 1;
}

die '-w option needs -d option' if($opts{'w'} && !$opts{'d'});

@modules = ();

if($opts{'B'}) {
	push @modules, 'File::Temp', 'Image::Resize',
		'String::ProgressBar', 'PDF::API2',
		'Text::Soundex', 'Text::Wrap',
		'Image::Magick::Thumbnail', 'HTTP::Cache::Transparent';
} elsif($opts{'T'} || $opts{'i'}) {
	push @modules, 'String::ProgressBar';
	if($opts{'i'}) {
		push @modules, 'Data::ICal', 'Date::ICal',
			'Data::ICal::Entry::Event',
			'Data::ICal::TimeZone', 'Data::ICal::DateTime';
	}
} elsif($opts{'H'}) {
	push @modules, 'HTML::Table';
} elsif($opts{'x'}) {
	push @modules, 'Text::Soundex';
} elsif($opts{'S'}) {
	push @modules, 'DBI';
}
if($ENV{'LANG'}) {
	push @modules, 'Locale::Country::Multilingual';
}
if($opts{'w'}) {
	push @modules, 'HTTP::Cache::Transparent', 'Genealogy::ChroniclingAmerica', 'Locale::Country';
}

my @needfull;
foreach my $module(@modules) {
	eval "require $module";
	if($@) {
		push @needfull, $module;
	} else {
		$module->import();
	}
}
if(scalar(@needfull)) {
	system('cpan -i ' . join(' ', @needfull));
}

foreach my $module(@modules) {
	my $version;
	if($module =~ /(.+)\s(.+)$/) {
		$module = $1;
		$version = $2;
	}
	eval "require $module";
	if($@) {
		die $@;
	}
	$module->import();
	# if($version && ($module::VERSION < $version)) {
		# die "$module: need $version got ", $module::VERSIOn;
	# }
}

my $browser;
my $cached_browser;
my $au = Locale::AU->new();
my $ca = Locale::CA->new();
my $us = Locale::US->new();
my $birth_country;
my $grave_modules;
if($opts{'w'} || $opts{'B'}) {
	$browser = LWP::UserAgent::Throttled->new(agent => basename($0), keep_alive => 1);
	$browser->env_proxy(1);
	$browser->conn_cache->total_capacity(undef);

	# Cache calls to openstreetmap etc.
	my $cachedir;
	if(my $e = $ENV{'CACHEDIR'}) {
		$cachedir = File::Spec->catfile($e, 'http-cache-transparent');
	} else {
		$cachedir = File::Spec->catfile(File::Spec->tmpdir(), 'cache', 'http-cache-transparent');
	}

	HTTP::Cache::Transparent::init({
		BasePath => $cachedir,
		Verbose => $opts{'v'} ? 1 : 0,
		NoUpdate => 60 * 60 * 24,
		MaxAge => 30 * 24
	}) || die "$0: $cachedir: $!";

	if($opts{'w'}) {
		# If you have a locally written module to look up entries, list them in gedcom.config, otherwise use
		# WWW::Scrape::FindaGrave
		my $config;

		eval { $config = Config::Auto::parse() };

		if($config && $config->{'grave_modules'}) {
			$grave_modules = $config->{'grave_modules'};

			if(ref($grave_modules)) {
				foreach my $module(@{$grave_modules}) {
					autoload $module;
				}
			} else {
				autoload $grave_modules;
			}
		# } else {
			# require WWW::Scrape::FindaGrave;
			# WWW::Scrape::FindaGrave->import();
		}
		# if(!$ged->validate() && $opts{'f'}) {
			# die "$ARGV[0] is not a valid gedcom file";
		# }

	}

	if(my $e = $ENV{'CACHEDIR'}) {
		$cachedir = File::Spec->catfile($e, 'lwp');
	} else {
		$cachedir = File::Spec->catfile(File::Spec->tmpdir(), 'cache', 'lwp');
	}
	mkdir $cachedir if(!-d $cachedir);
	$cached_browser = LWP::UserAgent::Cached->new(cache_dir => $cachedir,
		agent => basename($0),
		keep_alive => 1
	);
	$cached_browser->env_proxy(1);
}

my %all_dates;	# Maps dates to the hashref from Genealogy::Gedcom::Date
my $dtl = DateTime::Locale->load($ENV{'LANG'});
my $language;
if(defined($ENV{'LANG'}) && ($ENV{'LANG'} =~ /^fr/)) {
	$language = 'French';
} else {
	$language = 'English';
}

my $date_parser = Genealogy::Gedcom::Date->new();
my $dfn;
if($language eq 'French') {
	# $dfn = DateTime::Format::Natural->new(format => 'dd/mm/yy', lang => 'fr');	 # not supported
	$dfn = DateTime::Format::Natural->new(format => 'dd/md/yy');
} elsif(defined($ENV{'LANG'}) &&($ENV{'LANG'} =~ /^en_US/)) {
	$dfn = DateTime::Format::Natural->new();
} else {
	$dfn = DateTime::Format::Natural->new(format => 'dd/md/yy');
}
my $dfg = DateTime::Format::Genealogy->new();
my $tz = $ENV{'TZ'} // DateTime::TimeZone->new(name => 'local');

# my $geocoder = Geo::Coder::List->new(cache => CHI->new(driver => 'Memcached', servers => [ '192.168.1.15:11211', '127.0.0.1:11211' ]));
my $cachedir;
if(my $e = $ENV{'CACHEDIR'}) {
	$cachedir = File::Spec->catfile($e, basename($0));
} else {
	$cachedir = File::Spec->catfile(File::Spec->tmpdir(), 'cache', basename($0));
}
my $geocoder = Geo::Coder::List->new(cache => CHI->new(driver => 'File', root_dir => $cachedir))->push(Geo::Coder::Free::Local->new());
my $textgeocoder;

if(my $oa = $ENV{'OPENADDR_HOME'}) {
	$textgeocoder = Geo::Coder::Free->new(openaddr => $oa);
	# $geocoder->push({ regex => qr/,[\w\s]+,[\w\s]+$/, geocoder => $textgeocoder });
	# US, Canada and Australia are full
	# Counties and towns in the UK are full
	$geocoder->push({ regex => qr/,\s*(USA|US|United States|Canada|Australia)\s*$/, geocoder => $textgeocoder })
		->push({ regex => qr/^([\w\s]+,)?\s*[\w\s]+,\s*[\w\s]+\s*$/, geocoder => $textgeocoder });
} else {
	$textgeocoder = Geo::Coder::Free->new();
	$geocoder->push({ regex => qr/^[\w\s\-]+?,[\w\s]+,[\w\s]+?$/, geocoder => $textgeocoder })
		# E.g. 'Nebraska, USA'
		->push({ regex => qr/^[\w\s]+,\s*(UK|England|Canada|USA|US|United States)$/i, geocoder => $textgeocoder });
}

$geocoder->push({ regex => qr/^[\w\s]+,\s*[\w\s],\s*(UK|England|Wales|Scotland)$/i, geocoder => $textgeocoder });

if(my $username = $ENV{'GEONAMES_USER'}) {
	$geocoder->push(Geo::GeoNames->new(username => $username));
}

# DST isn't that good for the UK
# $geocoder->push({ regex => qr/(UK|United Kingdom|England|USA|US|United States|Wales)$/i, geocoder => Geo::Coder::DataScienceToolkit->new() })
$geocoder->push({ regex => qr/(USA|US|United States)$/i, geocoder => Geo::Coder::DataScienceToolkit->new() })
	->push({ regex => qr/^\d.+?,.+?,\s*(USA|US|United States)$/i, geocoder => Geo::Coder::US::Census->new() })
	->push({ limit => 100, regex => qr/(Canada|USA|United States)$/, geocoder => Geo::Coder::CA->new() })
	->push({ regex => qr/(USA|US|United States)$/i, geocoder => Geo::Coder::RandMcnally->new() })
	->push({ regex => qr/^[\w\s-]+,\s*[\w\s]+,\s*(UK|United Kingdom|England|Wales)$/i, geocoder => Geo::Coder::Postcodes->new() })
	->push(Geo::Coder::OSM->new())
	# ->push({ limit => 200, geocoder => Geo::Coder::XYZ->new()})
	->push(Geo::Coder::Ovi->new());
	# ->push(Geo::Coder::GeocodeFarm->new());	# Needs GT#1 to be fixed

if(my $key = $ENV{'GEO_CODER_OPENCAGE_API_KEY'}) {
	$geocoder->push({ limit => 200, geocoder => Geo::Coder::OpenCage->new(api_key => $key) });
}
if(my $key = $ENV{'GMAP_KEY'}) {
	$geocoder->push({ limit => 200, geocoder => Geo::Coder::GooglePlaces->new(key => $key, api_key => $key) });
}
if(my $key = $ENV{BMAP_KEY}) {
	$geocoder->push(Geo::Coder::Bing->new(key => $key));
}

if($browser) {
	$browser->throttle({
		'nominatim.openstreetmap.org' => 1,
		'geocode.xyz' => 2,
		'geocoder.ca' => 1,
		'opencagedata.com' => 1,
		'api.postcodes.io' => 1,
		'where.desktop.mos.svc.ovi.com' => 1,
		'geocoding.geo.census.gov' => 1,
		'a2ageo.rmservers.com' => 1,
		'dev.virtualearth.net' => 1,	# Bing
		'api.geonames.org' => 1,
		'yboss.yahooapis.com' => 1,	# Geo::Coder::PlaceFinder
	});
	# G::C::GooglePlaces
	$browser->throttle({ 'maps.googleapis.com' => 0.1 }) unless($ENV{GMAP_KEY});
	$browser->ssl_opts(verify_hostname => 0);	# prevent "Can't connect to geocode.xyz:443 (certificate verify failed)"
	$geocoder->ua($browser);

	# $textgeocoder = Geo::Parser::Text->new('https://geocoder.ca');
	# $textgeocoder = Geo::Parser::Text->new('https://geocode.xyz');

	# Geo::Coder::PlaceFinder doesn't support the ua() method
	if((my $ckey = $ENV{'YAHOO_CONSUMER'}) && (my $skey = $ENV{'YAHOO_SECRET'})) {
		$geocoder->push(Geo::Coder::PlaceFinder->new(consumer_key => $ckey, secret_key => $skey, ua => $browser));
	}
}

my $oneday = DateTime::Duration->new(days => 1);
my $tenmonths = DateTime::Duration->new(months => 10);
my $sixteenyears = DateTime::Duration->new(years => 16);
my $fortyyears = DateTime::Duration->new(years => 40);
my $pdf;
my $pdfpage;
my @tmpfiles;
my $pr;
my $dbh;
$ged = Class::Simple::Cached->new(object => $ged,
	cache => CHI->new(driver => 'RawMemory', datastore => {}));
my $ged2;
if($ARGV[1]) {
	$ged2 = Gedcom->new(gedcom_file => $ARGV[1], read_only => 1);
	$ged2 = Class::Simple::Cached->new(object => $ged2, cache => CHI->new(driver => 'RawMemory', datastore => {}));
}

my @everyone;
# Don't get everyone if we're after a specific person, or we're producing a book of a person
unless($opts{'p'} || (($opts{'A'} || $opts{'G'}) && $opts{'B'} && $opts{'h'})) {
	# @everyone = sort {
		# $a->as_string({ include_years => 1, middle_names => 1 }) cmp $b->as_string({ include_years => 1, middle_names => 1 })
		# } $ged->individuals();
	# @everyone = map { Class::Simple::Readonly::Cached->new(object => $_, cache => CHI->new(driver => 'RawMemory', datastore => {})) } $ged->individuals();
	@everyone = map { Class::Simple::Readonly::Cached->new({ object => $_, cache => {} }) } $ged->individuals();
}

if($opts{'c'} && !$opts{'d'}) {
	die '-c only makes sense with the -d option';
}
if($opts{'F'} && !$opts{'B'}) {
	die '-F only makes sense with the -B option';
}
if($opts{'m'} && !$opts{'H'}) {
	die '-m only makes sense with the -H option';
}
if($opts{'y'} && !$opts{'H'}) {
	die '-y only makes sense with the -H option';
}
if($opts{'L'} && !$opts{'H'}) {
	die '-L only makes sense with the -H option';
}
if($opts{'W'} && !$opts{'w'}) {
	warn '-W only makes sense with the -w option';
} elsif($opts{'w'} && !defined($ENV{'CLICOLOR'})) {
	$opts{'W'} = 1;
}
if($opts{'A'} && $opts{'G'}) {
	die '-A doesn\'t make sense with the -G option';
}
if($opts{'S'} && $opts{'B'}) {
	die '-S doesn\'t make sense with the -B option';
}

if($opts{'B'}) {
	$pdf = PDF::API2->new(-file => $opts{'B'});
	my $papersize;
	if((-r '/etc/papersize') && open(my $fin, '<', '/etc/papersize')) {	# Linux
		$papersize = <$fin>;
		close $fin;
		chomp $papersize;
	} elsif(defined($ENV{'LANG'}) &&($ENV{'LANG'} =~ /^en_US/)) {
		$papersize = 'letter';
	} else {
		$papersize = 'A4';
	}
	if($papersize eq 'letter') {
		$pdf->mediabox('Letter');
		$Text::Wrap::columns = 105;
	} else {
		$pdf->mediabox('A4');
		$Text::Wrap::columns = 110;
	}
	$opts{'A'} = 1 unless($opts{'G'});
} elsif($opts{'s'}) {
	die '-s only makes sense with the -B or -x options' unless($opts{'x'});
} elsif($opts{'S'}) {
	# FIXME - use basename of .ged with .sql suffix
	my $sqlite_file = 'gedcom.sql';

	if(-e $sqlite_file) {
		unlink $sqlite_file;
	}

	$dbh = DBI->connect("dbi:SQLite:dbname=$sqlite_file", undef, undef, { RaiseError => 1, AutoCommit => 0, synchronous => 0, locking_mode => 'EXCLUSIVE' });
	$dbh->do('PRAGMA cache_size = 65536');
	$dbh->do('PRAGMA journal_mode = OFF');

	$dbh->do('CREATE TABLE people(xref CHAR(6) NOT NULL, givennames VARCHAR, surname VARCHAR, mother CHAR(6), father CHAR(6), birth CHAR (12), death CHAR (12), PRIMARY KEY (xref), FOREIGN KEY (mother) REFERENCES people(xref), FOREIGN KEY (father) REFERENCES people(xref));');
	$dbh->do('CREATE TABLE siblings(xref CHAR(6), sibling CHAR(6) NOT NULL, PRIMARY KEY (xref, sibling), FOREIGN KEY (sibling) REFERENCES people(xref));');
	$dbh->do('CREATE TABLE children(xref CHAR(6), child CHAR(6) NOT NULL, PRIMARY KEY (xref, child), FOREIGN KEY (child) REFERENCES people(xref));');
	$dbh->do('CREATE TABLE spouses(xref CHAR(6), spouse CHAR(6) NOT NULL, dateofmarriage CHAR (12), placeofmarriage CHAR (30), PRIMARY KEY (xref, spouse), FOREIGN KEY (spouse) REFERENCES people(xref));');
	$dbh->do('CREATE TABLE locations(location CHAR (30), PRIMARY KEY (location));');
	$dbh->do('CREATE TABLE residences(xref CHAR (6), date CHAR (12), location CHAR (30), FOREIGN KEY (xref) REFERENCES people(xref), FOREIGN KEY (location) REFERENCES locations(location));');
	$dbh->do('CREATE TABLE occupations(xref CHAR (6), occupation CHAR (20), FOREIGN KEY (xref) REFERENCES people(xref));');
}

if($opts{'A'} || $opts{'G'} || $opts{'S'}) {
	$opts{'a'} = 1;
}
if($opts{'x'}) {
	if($opts{'g'}) {
		die '-g and -x option are exclusive'
	}
	$opts{'T'} = 1;
} elsif($opts{'g'}) {
	$opts{'T'} = 1;
}
if($opts{'T'}) {
	$opts{'A'} = $opts{'a'} = $opts{'d'} = 1;
}
my $ical;
if($opts{'i'}) {
	if($opts{'T'}) {
		die '-i and -T are exclusive';
	}
	$ical = Data::ICal->new();
	$ical->add_properties(
		calscale => 'GREGORIAN',
		method => 'PUBLISH',
		'X-WR-CALNAME' => "$0 Family Calendar",
	);
	$opts{'A'} = $opts{'a'} = 1;
}

my $dot;
if($opts{'B'}) {
	if(-x '/usr/bin/dot') {
		$dot = '/usr/bin/dot';
	} elsif(-x '/usr/local/bin/dot') {
		$dot = '/usr/local/bin/dot';
	} elsif(-x '/sw/bin/dot') {
		$dot = '/sw/bin/dot';
	}

	if(!defined($dot)) {
		complain(warning => 'Graphviz not found, no family trees');
	} elsif($opts{'v'}) {
		print "Using $dot\n";
	}
}

my $lcm;
if($ENV{'LANG'}) {
	$lcm = Class::Simple::Cached->new(object => Locale::Country::Multilingual->new(),
		cache => CHI->new(driver => 'RawMemory', datastore => {}));
}

if($opts{'H'}) {
	die '-H only makes sense with the -d option' unless($opts{'d'});
	die '-a doesn\'t make sense with the -H option' if($opts{'a'});
	die '-h doesn\'t make sense with the -H option' if($opts{'h'});
	die '-p doesn\'t make sense with the -H option' if($opts{'p'});
	die '-H doesn\'t support citations' if($opts{'c'});

	my $dtl = DateTime::Locale->load($ENV{'LANG'});

	my @dow = @{$dtl->day_format_wide()};
	if($dtl->first_day_of_week() eq 7) {
		# e.g. US
		unshift @dow, pop @dow;
	}
	my $table = HTML::Table->new(-border => 1, -padding => 5, -head => \@dow);
	print '<html><head><title>Gedcom Calendar</title></head><body><font size="2">',
		'<style>table { empty-cells: show; }</style>';

	foreach my $day(0..6) {
		# $table->setCell(1, $day + 1, $days[$day]);
		$table->setColWidth($day, '14.29%');
		$table->setColVAlign($day, 'top');
	}

	my $month;
	if($opts{'m'}) {
		$month = $opts{'m'};
		if(($month =~ /\D/) || ($month < 1) || ($month > 12)) {
			die "$0: invalid month number $month";
		}
		$month--;
	} else {
		$month = (localtime)[4]; # 0..11
	}

	my $dt = DateTime->today();
	my $year;
	if($opts{'y'}) {
		$year = $opts{'y'};
		if($year !~ /\d{3,4}/) {
			die "$0: invalid year number $month";
		}
	} else {
		$year = $dt->year();
	}

	$dt = DateTime->last_day_of_month(month => $month + 1, year => $year);
	$dt->subtract(months => 1);
	$dt->add(days => 1);
	my $column = $dt->day_of_week();
	if($dtl->first_day_of_week() eq 7) {
		$column++;
		if($column == 8) {
			$column = 1;
		}
	}

	foreach my $column(1..7) {
		$table->setCell(2, $column, '&nbsp;');
	}

	my $row = 2;
	while($dt->month() == $month + 1) {
		$table->setCellVAlign($row, $column, 'top');
		$table->setCell($row, $column, '<font size="1">' . $dt->day() . '</font>');
		$dt->add(days => 1);
		if($dt->day() == 1) {
			last;
		}
		if($column == 7) {
			$row++;
			foreach my $column(1..7) {
				$table->setCell($row, $column, '&nbsp;');
			}
			$column = 1;
		} else {
			$column++;
		}
	}

	print "<center><h2>", @{$dtl->month_format_wide()}[$month], " $year</h2></center>";

	foreach my $day(1..28) {
		generate(day => $day, month => $month, year => $year, everyone => \@everyone, table => $table, dtl => $dtl);
	}
	if($month == 1) {
		# February
		if(($year % 100) == 0) {
			if(($year % 400) == 0) {
				generate(day => 29, month => $month, everyone => \@everyone);
			}
		} elsif(($year % 4) == 0) {
			generate(day => 29, month => $month, everyone => \@everyone);
		}
	} else {
		generate(day => 29, month => $month, year => $year, everyone => \@everyone, table => $table, dtl => $dtl);
		generate(day => 30, month => $month, year => $year, everyone => \@everyone, table => $table, dtl => $dtl);
		if(($month == 0) || ($month == 2) || ($month == 4) || ($month == 6) || ($month == 7) || ($month == 9) || ($month == 11)) {
			generate(day => 31, month => $month, year => $year, everyone => \@everyone, table => $table, dtl => $dtl);
		}
	}
	print '<center>';
	$table->print();
	print '</center></font></body></html>';
} elsif($opts{a}) {
	die '-b and -a should not be given together' if($opts{'b'});
	die '-D and -a should not be given together' if($opts{'D'});
	die '-p and -a should not be given together' if($opts{'p'});

	if($opts{'A'} || $opts{'G'}) {
		my $surname;

		if($opts{'s'}) {
			if($opts{'h'} =~ /\s*([A-Z]+?)$/i) {
				$surname = $1;
			} else {
				$surname = $opts{'h'};
			}
		}
		if($opts{'B'}) {
			if($opts{'h'}) {
				my $page = $pdf->page();

				my $font = $pdf->corefont('Times-Bold');

				my $text = $page->text();
				$text->font($font, 28);
				$text->translate(300, 600);
				if($opts{'s'}) {
					$text->text_center("The Surname Book of $surname");
				} else {
					$text->text_center('The Family Tree of');
					$text->translate(300, 525);
					$text->text_center(normalize_name($opts{'h'}));
				}
				my %args;
				if(defined($ENV{'TZ'}) && ($ENV{'TZ'} !~ /^\//)) {
					$args{'time_zone'} = $ENV{'TZ'};
				} else {
					$args{'time_zone'} = $tz;
				}
				my $dt = DateTime->today(%args);
				my $dtl = DateTime::Locale->load($ENV{'LANG'});
				if($opts{'s'}) {
					$text->translate(300, 525);
				} else {
					$text->translate(300, 450);
				}
				$text->text_center('Compiled on ' .
					$dt->day() . ' ' .
					@{$dtl->month_format_wide()}[$dt->month - 1] . ' ' .
					$dt->year()
				);
				if($opts{'s'} && !$opts{'G'}) {
					$text->translate(300, 450);
					if(is_alive(person => $me)) {
						$text->text_center('for ' . normalize_name($opts{'h'}));
					} else {
						my $n = normalize_name($me->as_string(include_years => 1));
						$n =~ s/\sC(\d)/ c$1/;
						$text->text_center("for $n");
					}
				}
				$text->font($font, 12);
				$text->translate(220, 40);
				$text->text('Produced by gedcom - https://github.com/nigelhorne/gedcom');
				$text->textend();

				# my $gfx = $page->gfx();
				# my $image = $pdf->image_png('/Users/njh/src/njh/ged2site/dynamic-site/images/printer.png');
				# $gfx->image($image, 100, 100);
				# $image->height(32);
				# $image->width(32);

				if($opts{'F'}) {
					@everyone = ($me, ancestors($me));
				} else {
					@everyone = ($me, ancestors($me), descendents($me));
					my @siblings = ($me->siblings(), $me->half_siblings());
					foreach my $sibling(@siblings) {
						# print $sibling->as_string(), "\n";
						@everyone = descendents($sibling, \@everyone);
					}
					@everyone = (@everyone, @siblings);
				}

			} elsif($opts{'s'}) {
				die '-s and -h must be given together';
			}
		}

		if($surname) {
			my $nara = soundex_nara($surname);
			# @everyone = grep { $_->as_string() =~ /.*$surname$/i } @everyone;
			@everyone = grep { ($_->as_string() =~ /$surname$/i) || ($_->surname() && (soundex_nara($_->surname()) eq $nara)) } @everyone;
		}

		if(scalar(@everyone) == 0) {
			die 'No matches found for ', $me->as_string(include_years => 1);
		}

		if($opts{'B'} || $opts{i} || ((!$opts{'x'}) && (!$opts{'A'}) && !$opts{'g'})) {
			$pr = String::ProgressBar->new(max => scalar(@everyone), length => 60);
		}

		if($opts{'G'}) {
			if($me->father() || $me->mother()) {
				print STDERR $me->as_string({ include_years => 1, middle_names => 1, nee => 1 }), ":\n\t";
				die 'A generations book (-B and -G) must have the -h person at the top of the tree';
			}
			# Put a family tree of the first few generations on page 2
			# Fit as many as we can until the text is going to become too small
			my $tmp = File::Temp->new();
			my $filename = $tmp->filename();
			my $png = '/tmp/njh.png';	# FIXME

			my $maxrank = 2;
			while(1) {
				my $d = count_descendents_at_level($me, $maxrank + 1);
				last if($d == 0);
				last if($d >= 3);

				$maxrank++;
			}

			if(open(my $fout, '|-', "$dot -Tpng -o$png -Tcmapx -o$filename")) {
			# if(open(my $fout, '|-', '/usr/bin/tee foo')) {
				print $fout 'digraph family {',
					'rotate = 90 subgraph main { rank="0"; ';
				print_graphviz({ person => $me, fout => $fout, format => 'dynamic' });
				print_graphviz_generation({ person => $me, fout => $fout, format => 'dynamic', rank => 0, maxrank => $maxrank + 1 });
				print $fout '}}';
				close $fout;

				my $image;
				my $resize = Image::Resize->new($png);
				my $width = $resize->width();
				my $height = $resize->height();
				my $gd;
				if($height > 715) {
					my $newwidth = $width * (715 / $height);
					if($newwidth > 550) {
						my $newheight = $height * (550 / $width);
						$gd = $resize->resize(550, $newheight);
					} else {
						$gd = $resize->resize($newwidth, 715);
					}
				} elsif($width > 550) {
					my $newheight = $height * (550 / $width);
					$gd = $resize->resize(550, $newheight);
				}
				if($gd) {
					$image = $pdf->image_gd($gd, -lossless => 1);
					unlink $png;
				} else {
					$image = $pdf->image_png($png);
					push @tmpfiles, $png;
				}
				$pdfpage = PDFPage->new();
				my $x = 300 - ($image->width() / 2);
				my $y = $pdfpage->y() - $image->height();
				$pdfpage->page()->gfx()->image($image, $x, $y);
				$pdfpage = PDFPage->new();
			}

			# FIXME: This sorting only works when all people are descendents of $me,
			# there are no ancestors involved
			@everyone = map { Class::Simple::Readonly::Cached->new({ object => $_, cache => {} }) } @everyone;
			@everyone = sort {
				(stepsabove($a, $me, 0) == stepsabove($b, $me, 0)) ?
					$a->as_sort_key() cmp $b->as_sort_key() :
					stepsabove($a, $me, 0) <=> stepsabove($b, $me, 0);
			} @everyone;

			die "BUG: sort hasn't worked" if($everyone[0]->xref() ne $me->xref());
		} elsif($opts{'h'} && !$opts{'x'}) {
			# Put a family tree going back a few generations on page 2
			# Go back until it looks like it will be very small text
			my $tmp = File::Temp->new();
			my $filename = $tmp->filename();
			my $png = '/tmp/njh.png';	# FIXME
			my $top = $me;

			my $level = 0;
			while(1) {
				my $parent;
				if($top->father()) {
					$parent = $top->father();
				} elsif($top->mother()) {
					$parent = $top->mother();
				} else {
					last;
				}
				if(count_descendents_at_level($parent, $level + 1) > 20) {
					last;
				}
				$top = $parent;
				$level++;
				# print $top->as_string(), " $level, ", count_descendents_at_level($top, $level), "\n";
			}

			if(($top->xref() ne $me->xref()) && $dot && open(my $fout, '|-', "$dot -Tpng -o$png -Tcmapx -o$filename")) {
			# if(open(my $fout, '|-', '/usr/bin/tee foo')) {
				print $fout 'digraph family {',
					'rotate = 90 subgraph main { rank="0"; ';
				print_graphviz({ person => $top, fout => $fout, format => 'dynamic' });
				print_graphviz_generation({ person => $top, fout => $fout, format => 'dynamic', rank => 0, maxrank => $level + 1 });
				print $fout '}}';
				close $fout;

				my $image;
				my $resize = Image::Resize->new($png);
				my $width = $resize->width();
				my $height = $resize->height();
				my $gd;
				if($height > 715) {
					my $newwidth = $width * (715 / $height);
					if($newwidth > 550) {
						my $newheight = $height * (550 / $width);
						$gd = $resize->resize(550, $newheight);
					} else {
						$gd = $resize->resize($newwidth, 715);
					}
				} elsif($width > 550) {
					my $newheight = $height * (550 / $width);
					$gd = $resize->resize(550, $newheight);
				}
				if($gd) {
					$image = $pdf->image_gd($gd, -lossless => 1);
					unlink $png;
				} else {
					$image = $pdf->image_png($png);
					push @tmpfiles, $png;
				}
				$pdfpage = PDFPage->new();
				my $x = 300 - ($image->width() / 2);
				my $y = $pdfpage->y() - $image->height();
				$pdfpage->page()->gfx()->image($image, $x, $y);
			}
			@everyone = map { Class::Simple::Readonly::Cached->new({ object => $_, cache => {} }) } @everyone;
			@everyone = Sort::Key::keysort { $_->as_sort_key() } @everyone;
		}

		generate(everyone => \@everyone, dbh => $dbh);

		if($opts{'B'}) {
			$pdf->save();
			unlink @tmpfiles;
		}
	} else {
		foreach my $month(0..11) {
			foreach my $day(1..28) {
				generate(day => $day, month => $month, everyone => \@everyone);
			}
			if($month == 1) {
				my $year = DateTime->today()->year();
				next if($year % 4);
				if(($year % 100) == 0) {
					next unless($year % 400);
				}
				generate(day => 29, month => $month, everyone => \@everyone);
				next;
			}
			generate(day => 29, month => $month, everyone => \@everyone);
			generate(day => 30, month => $month, everyone => \@everyone);
			if(($month == 0) || ($month == 2) || ($month == 4) || ($month == 6) || ($month == 7) || ($month == 9) || ($month == 11)) {
				generate(day => 31, month => $month, everyone => \@everyone);
			}
		}
		generate(day => -1, month => -1, everyone => \@everyone);
	}
} elsif($opts{'b'}) {
	die '-b and -d should not be given together' if($opts{'d'});
	die '-b and -a should not be given together' if($opts{'a'});
	my($day, $month) = (localtime)[3,4];
	if($opts{'D'}) {
		print "Today's birthdays:\n";
	}
	generate(day => $day, month => $month, onlybirthdays => 1, onlydeaths => 0, everyone => \@everyone);
	if($opts{'D'}) {
		print "Today's anniversaries of deaths:\n";
		generate(day => $day, month => $month, onlybirthdays => 0, onlydeaths => 1, everyone => \@everyone);
	}
} elsif($opts{'D'}) {
	die '-D and -d should not be given together' if($opts{'d'});
	die '-D and -a should not be given together' if($opts{'a'});
	my($day, $month) = (localtime)[3,4];
	generate(day => $day, month => $month, onlybirthdays => 0, onlydeaths => 1, everyone => \@everyone);
} elsif($opts{'p'}) {
	die '-p and -D should not be given together' if($opts{'D'});
	die '-p and -b should not be given together' if($opts{'b'});

	my @people = $ged->get_individual($opts{p});
	if(@people) {
		my($day, $month) = (localtime)[3,4];

		foreach my $person(@people) {
			print_person(person => $person, day => $day, month => $month);
		}
	} else {
		die "$0: Can't find '$opts{p}' in $ARGV[0]";
	}
} elsif(!$opts{'t'}) {
	my($day, $month) = (localtime)[3,4];
	generate(day => $day, month => $month, everyone => \@everyone);
} else {
	my %args = ('time_zone' => $tz);
	my $dt = DateTime->now(%args)->add(days => 1);
	generate(day => $dt->day(), month => $dt->month() - 1, everyone => \@everyone);
}

if($opts{'T'}) {
	# my $g;
	# if(my $oa = $ENV{'OPENADDR_HOME'}) {
		# $g = Geo::Coder::Free::OpenAddresses->new(openaddr => $oa);
	# }
	print '"Location","People"', "\n" if($opts{'x'});
	print '<?xml version="1.0" encoding="UTF-8"?>', "\n",
		'<kml xmlns="http://www.opengis.net/kml/2.2">', "\n",
		"<Document>\n" if($opts{'g'});
	foreach my $place(sort keys %all_places) {
		my @locations;
		if($opts{'x'}) {
			$place =~ s/"//g;
			print "\"$place\",\"";
		} elsif($opts{'g'}) {
			@locations = $geocoder->geocode($place);
			if((scalar(@locations) == 0) || !defined($locations[0]->{geometry}{location}{lat})) {
				complain(warning => "$place not found");
				next;
			}
			my $x_place = $place;
			$x_place =~ s/&/&amp;/g;
			print "\t<Placemark>\n",
				"\t\t<name>$x_place</name>\n",
				"\t\t<description>";
		} else {
			print "$place: ";
		}
		my $previous;
		foreach my $person(@{$all_places{$place}}) {
			if($previous && ($person eq $previous)) {
				next;
			}
			print $person->as_string({ include_years => 1, middle_names => 1, nee => 1 }),
				';';
			$previous = $person;
		}
		print '"' if($opts{'x'});
		if($opts{'g'}) {
			print "</description>\n",
				"\t\t<Point>\n",
				"\t\t\t<coordinates>",
					$locations[0]->{geometry}{location}{lng},
					',',
					$locations[0]->{geometry}{location}{lat},
				"</coordinates>\n",
				"\t\t</Point>\n",
				"\t</Placemark>";
		}
		print "\n";
		# if($g && ($place =~ /USA|Canada/)) {
			# my @locations = $g->geocode($place);
			# if(scalar(@locations) == 0) {
				# # complain(person => $person, warning => "$place not found in Geo::Coder::Free");
				# warn colored(['red'], "$place not found in Geo::Coder::Free");
			# }
		# }
	}
	print "</Document>\n</kml>\n" if($opts{'g'});
}

if($ical) {
	open(my $fout, '>', $opts{'i'});
	print $fout $ical->as_string();
	close $fout;
	print "\n" if($pr);
} elsif($opts{'S'}) {
	$dbh->commit();
	$dbh->disconnect();
}

sub generate {
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $surname_initial;
	if($opts{'B'}) {
		$params{'font'} = $pdf->corefont('Times-Roman');
	}
	my $index = 1;
	my $generation = 0;
	my %locations;

	foreach my $person(@{$params{'everyone'}}) {
	# foreach my $person(sort { $a->get_value('last name') cmp $b->get_value('last name') } $ged->individuals()) {
		my $xref = $person->xref();
		if($me && ($xref eq $me->xref()) && !$opts{'a'}) {
			$index++;
			next;
		}

		next if($printed{$xref});
		$printed{$xref} = 1;

		if($pr) {
			$| = 1;
			$pr->update($index++);
			$pr->write();
			$| = 0;
		}
		if($opts{'S'}) {
			# Create an SQLite database
			my $mother = $person->mother() || 'NULL';
			my $father = $person->father() || 'NULL';

			if($mother ne 'NULL') {
				$mother = $mother->xref();
			}
			if($father ne 'NULL') {
				$father = $father->xref();
			}

			my $name = $person->name();
			$name =~ s/\///g;
			$nameparser->parse($name);
			my %name_components = $nameparser->components();
			my $firstname = $person->given_names() // $name_components{'given_name_1'};
			if($firstname) {
				$firstname =~ s/\'/\\\'/g;
			} else {
				$firstname = 'NULL';
			}
			my $surname = $name_components{'surname_1'};
			if($surname) {
				$surname =~ s/\'/\\\'/g;
			} else {
				$surname = 'NULL';
			}

			print "$firstname, $surname\n";

			my $dateofbirth = dateofbirth($person);
			if($dateofbirth) {
				$dateofbirth =~ tr/\//-/;
			} else {
				$dateofbirth = 'NULL';
			}

			my $dateofdeath = dateofdeath($person);

			if($dateofdeath) {
				$dateofdeath =~ tr/\//-/;
			} else {
				$dateofdeath = 'NULL';
			}
			my $query = "INSERT INTO people('xref', 'givennames', 'surname', 'mother', 'father', 'birth', 'death') VALUES (?, ?, ?, ?, ?, ?, ?);";
			my $statement = $dbh->prepare($query);
			print "$xref: $firstname $surname\n";
			die unless($statement->execute($xref, $firstname, $surname, $mother, $father, $dateofbirth, $dateofdeath) == 1);

			my @siblings = $person->siblings();
			if(scalar(@siblings)) {
				$query = "INSERT INTO siblings('xref', 'sibling') VALUES (?, ?);";
				$statement = $dbh->prepare($query);
				foreach my $s(@siblings) {
					print ">$xref: $surname: ", $s->xref(), "\n";
					die unless($statement->execute($xref, $s->xref()) == 1);
				}
			}

			my @children = $person->children();
			if(scalar(@children)) {
				$query = "INSERT INTO children('xref', 'child') VALUES (?, ?);";
				$statement = $dbh->prepare($query);
				foreach my $c(@children) {
					print ">>$xref: $surname: ",
						$c->xref(), ': ',
						$c->given_names(), "\n";
					die unless($statement->execute($xref, $c->xref()) == 1);
				}
			}

			my @spouses = $person->spouse();
			if(scalar(@spouses)) {
				$query = "INSERT INTO spouses('xref', 'spouse', 'dateofmarriage', 'placeofmarriage') VALUES (?, ?, ?, ?);";
				$statement = $dbh->prepare($query);
				foreach my $spouse(@spouses) {
					my $date = get_value({ person => $spouse, value => 'marriage date' });
					my $marriage = $spouse->get_record('marriage') || $spouse->get_record('fams marriage');
					if((!defined($date)) && $marriage) {
						$date = $marriage->date();
					}
					if(!defined($date)) {
						$date = 'NULL';
					}
					my $place = get_value({
						person => $person,
						value => 'marriage place',
					});
					if((!defined($place)) && $marriage) {
						$place = $marriage->place();
					}
					if($place) {
						$place = place({
							person => $person,
							record => $place,
							nopreposition => 1
						});
						$place =~ s/^\s+//g;
					} else {
						$place = 'NULL';
					}
					print ">>>$xref: $surname, $date, $place: ",
						$spouse->xref(),
						"\n",
						$spouse->as_string(),
						"\n";
					die unless($statement->execute($xref, $spouse->xref(), $date, $place) == 1);
				}
			}
			my @residences = get_all_residences($person);
			if(scalar(@residences)) {
				$query = "INSERT INTO residences('xref', 'date', 'location') VALUES (?, ?, ?);";
				$statement = $dbh->prepare($query);
				foreach my $residence(@residences) {
					my $date = $residence->date() || 'NULL';
					my $place;
					if($residence->place()) {
						$place = place({
							person => $person,
							record => $residence,
							nopreposition => 1
						});
						$place =~ s/^\s+//g;
						$locations{$place} = $residence;
					} else {
						$place = 'NULL';
					}
					print ">>>>$xref: $date, $place\n";
					die unless($statement->execute($xref, $date, $place) == 1);
				}
			}
			my @occupations = get_all_occupations(person => $person);
			if(scalar(@occupations)) {
				$query = "INSERT INTO occupations('xref', 'occupation') VALUES (?, ?);";
				$statement = $dbh->prepare($query);
				foreach my $occupation(@occupations) {
					print ">>>>>$xref: $occupation\n";
					die unless($statement->execute($xref, $occupation) == 1);
				}
			}

			next;
		} elsif($ical) {
			my $dateofbirth = dateofbirth($person);
			if($dateofbirth && ($dateofbirth =~ /^\d+\s\w{3}\s\d{3,4}$/)) {
				add_to_ical(
					ical => $ical,
					datetime => date_to_datetime(date => $dateofbirth),
					summary => 'birth of ' . $person->as_string()
				);
			}
			my $dateofbaptism = get_value({ person => $person, value => 'baptism date' });
			if((!$dateofbaptism) && (my $baptism = $person->get_record('baptism'))) {
				$dateofbaptism = $baptism->date();
			}
			if($dateofbaptism && ($dateofbaptism =~ /^\d+\s\w{3}\s\d{3,4}$/)) {
				add_to_ical(
					ical => $ical,
					datetime => date_to_datetime(date => $dateofbaptism),
					summary => 'baptism of ' . $person->as_string()
				);
			}
			if(my $marriage = $person->get_record('marriage') || $person->get_record('fams marriage')) {
				if(my $dateofmarriage = $marriage->date()) {
					if($dateofmarriage && ($dateofmarriage =~ /^\d+\s\w{3}\s\d{3,4}$/)) {
						# FIXME: work with more than one spouse
						my @spouses = $person->spouse();
						if(scalar(@spouses) == 1) {
							add_to_ical(
								ical => $ical,
								datetime => date_to_datetime(date => $dateofmarriage),
								summary => 'marriage of ' . $person->as_string() . ' and ' . $spouses[0]->as_string()
							);
						}
					}
				}
			}
			my $dateofdeath = dateofdeath($person);
			if($dateofdeath && ($dateofdeath =~ /^\d+\s\w{3}\s\d{3,4}$/)) {
				add_to_ical(
					ical => $ical,
					datetime => date_to_datetime(date => $dateofdeath),
					summary => 'death of ' . $person->as_string()
				);
			}
			my $dateofburial = get_value({ person => $person, value => 'burial date' });
			if((!defined($dateofburial)) && (my $burial = $person->get_record('burial'))) {
				$dateofburial = $burial->date();
			}
			if($dateofburial && ($dateofburial =~ /^\d+\s\w{3}\s\d{3,4}$/)) {
				add_to_ical(
					ical => $ical,
					datetime => date_to_datetime(date => $dateofburial),
					summary => 'burial of ' . $person->as_string()
				);
			}
			next;
		}

		if($opts{'B'}) {
			if($opts{'G'}) {
				if(stepsabove($person, $me, 0) != $generation) {
					# FIXME:  only do this if the generation contains dead people if the -l flag is not given
					$pdfpage = PDFPage->new();
					$generation = stepsabove($person, $me, 0);

					my $font = $pdf->corefont('Times-Bold');
					my $text = $pdfpage->text();
					$text->font($font, 18);

					$text->translate(300, $pdfpage->newline());

					my $t;

					if($generation >= 5) {
						$t = ($generation - 2) . ' times great-grandchildren';
					} elsif($generation == 1) {
						$t = 'Children';
					} elsif($generation == 2) {
						$t = 'Grandchildren';
					} elsif($generation == 3) {
						$t = 'Great-grandchilden';
					} elsif($generation == 4) {
						$t = 'Great-great-grandchildren';
					} else {
						# May have found a spouse with the same name, so it shouldn't be included
						next unless($person->father() || $person->mother());
						die $person->as_string(), '/', $me->as_string(), "; -G ($generation): Doesn't yet support ancestors";
					}
					$text->text_center($t);

					$text->font($params{'font'}, 12);
				}
			} else {
				my $surname = $person->surname() || '?';
				my $initial = substr $surname, 0, 1;
				if((!defined($surname_initial)) || ($initial ne $surname_initial)) {
					$pdfpage = PDFPage->new();
					$surname_initial = $initial;
				}
			}
		}

		$params{'person'} = $person;
		print_person(\%params);

		if($opts{'v'}) {
			my $log = $geocoder->log();
			$geocoder->flush();
			foreach my $l(@{$log}) {
				if($l->{'line'}) {
					print 'Line ', $l->{'line'}, ': ';
				}
				if($l->{'error'}) {
					print $l->{'error'}, ', ';
				}
				if($l->{geocoder}) {
					if($l->{error}) {
						print $l->{location}, ': ', $l->{timetaken}, 's with ', $l->{geocoder}, '(', $l->{error}, ")\n";
					} else {
						print $l->{location}, ': ', $l->{timetaken}, 's with ', $l->{geocoder}, "\n";
					}
				} else {
					print $l->{location}, ": cached\n";
				}
			}
		}
	}
	if($opts{'S'}) {
		my $query = "INSERT INTO locations('location') VALUES (?);";
		my $statement = $dbh->prepare($query);
		while(my($k, $v) = each(%locations)) {
			die unless($statement->execute($k) == 1);
		}
	} elsif($opts{'B'}) {
		print "\n";
	}
}

sub print_person
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	# Gather the information on this person
	my $person = $params{'person'};

	my $dob = dateofbirth($person);

	# ACOM starts approximate dates with "Abt." instead of "ABT".
	if(defined($dob) && length($dob) && ($dob ne '?')) {
		$dob =~ tr/\.\-/  /;
		$dob =~ s/\s{2,}/ /gs;
		# FIXME: ../../../gedcoms/gl120368.ged puts dates *inside*
		#	brackets
		$dob =~ s/\(.+$//;	# some people put information in brackets after the date
		if($dob =~ /^About[:\s](.+)/i) {
			$dob = "ABT$1";
		} elsif($dob =~ /^Bet\s[a-z]{3}.+([a-z]{3}\s+.*)/i) {	# Bet Jun-Jul 1860
			$dob = "ABT $1";
		} elsif($dob =~ /^(.+)\s*\?/i) {
			$dob = "ABT$1";
		}
		if(length($dob) && ($dob !~ /^[\d\sA-Z\/]+$/i) && ($dob !~ /^Abt\./)) {
			if($dob =~ /(\d{4})\s*(.+)/) {
				my $d = $1;
				my $t = $2;
				# Allow 1914-1918
				if($t !~ /\d{3,4}$/) {
					$dob = "ABT$d";
					if(place({ person => $person, place => $t })) {
						complain({ person => $person, warning => "Unexpected text ($t) after the date $d - should be in the location record" });
					} else {
						complain({ person => $person, warning => "Unexpected text ($t) after the date $d - should be in the note field" });
					}
				}
			} elsif($dob !~ /\d{1,2}$/) {	# Dates can begin with a letter in the US
				complain({ person => $person, warning => "Invalid character in date of birth '$dob'" });
				$dob = undef;
			}
		}
	}

	my $onlybirthdays = $params{'onlybirthdays'};
	my $onlydeaths = $params{'onlydeaths'};

	die "BUG: onlydeaths and onlybirths given" if($onlydeaths && $onlybirthdays);

	return if($onlybirthdays && !defined($dob));

	my $dod = dateofdeath($person);

	return if($onlydeaths && !defined($dod));

	my $yod;	# Year of death
	if($dod && ($dod =~ /.*?(\d{3,4})/)) {
		$yod = $1;
	}

	my $yob;	# Year of birth
	if($dob && ($dob =~ /.*?(\d{3,4})/)) {
		$yob = $1;
	} elsif($dob) {
		if(($dob eq 'UNKNOWN') || ($dob eq '?')) {
			$dob = undef;
		} elsif($opts{'w'} && !$warned{$person}) {
			complain({ person => $person, warning => "Invalid date of birth $dob" });
			$warned{$person} = 1;
		}
	}

	return unless($dob || $dod || $opts{'a'} || $opts{'p'});

	if((!defined($opts{l})) && (!defined($yod)) && defined($yob) && ($yob > 1900)) {
		# Assuming living if we don't have a date of death and
		# they were born after 1900
		return;
	}

	# print 'Checking ', $person->as_string({ include_years => 1 }), "\n" if($opts{'v'});

	my $print = 0;
	my $aob;
	my $aod;
	my $day = $params{'day'};
	my $month = $params{'month'};

	if($day) {
		if($dob && ($dob !~ /^\d{3,4}$/)) {
			my @btime = strptime("$dob 12:00");
			if(defined($btime[3]) && ($btime[3] == $day) && ($btime[4] == $month) && $btime[5]) {
				$print = 1;
				if(!$opts{a}) {
					$aob = (localtime)[5] - $btime[5];
					if($aob <= 0) {
						$aob += 1900;
					}
				}
			}
		}
		return if($onlybirthdays && !defined($aob));

		if($dod && ($dod !~ /^\d{3,4}$/)) {
			my @dtime = strptime("$dod 12:00");
			if(defined($dtime[3]) && ($dtime[3] == $day) && ($dtime[4] == $month) && $dtime[5]) {
				$print = 1;
				if(!$opts{a}) {
					$aod = (localtime)[5] - $dtime[5];
					if($aod <= 0) {
						$aod += 1900;
					}
				}
			}
		}
		return if($onlydeaths && !defined($aod));

		return unless($print || ($day == -1) || $opts{'p'});
	}

	if($opts{'w'} && !$person->validate_semantics()) {
		complain({ person => $person, warning => 'failed consistency check' });
	}

	my @siblings = $person->siblings();
	my $mother = $person->mother();
	my $father = $person->father();
	my @spouses = $person->spouse();

	# TODO: Properly chart which spouse a child comes from
	if($opts{'w'}) {
		my $family;
		foreach my $f($person->fams()) {
			if($f->number_of_children()) {
				$family = $f;
				last;
			}
		}

		if((!$family) && (scalar(@siblings) == 0) && (!$mother) && !$father) {
			if(scalar(@spouses) == 0) {
				# This person isn't connected to anyone
				# TODO: catch "islands" of people connected to each other, but nobody else
				complain({ person => $person, warning => 'Not connected to the tree' });
			} elsif(scalar(@spouses) == 1) {
				my $spouse = $spouses[0];
				my $sf;
				foreach my $f($spouse->fams()) {
					if($f->number_of_children()) {
						$sf = $f;
						last;
					}
				}
				my @ss = $spouse->spouse();
				if((!$sf) && (!$spouse->mother()) && (!$spouse->father()) && (!$spouse->siblings()) && (scalar(@ss) == 1)) {
					complain({ person => $person, warning => 'Spouses connect to each other but no-one else' });
				}
			}
		}
		if((!$family) && (scalar(@siblings) == 1) && (scalar(@spouses) == 0) && (!$mother) && !$father) {
			my $sibling = $siblings[0];
			my $sf;
			foreach my $f($sibling->fams()) {
				if($f->number_of_children()) {
					$sf = $f;
					last;
				}
			}
			my @ss = $sibling->spouse();
			if((!$sf) && (!$sibling->mother()) && (!$sibling->father()) && (scalar(@ss) == 0)) {
				complain({ person => $person, warning => 'Siblings connect to each other but no-one else' });
			}
		}

		# FIXME: needs to only complain about more than two biological parents
		my @parents = $person->parents();
		if(scalar(@parents) > 2) {
			complain({ person => $person, warning => 'Has more than two parents' });
		}
	}

	my $year = $params{'year'} || (localtime)[5];
	$year += 1900 if($year < 1900);

	if($opts{'H'}) {
		my $start_of_month = DateTime->new(month => $month + 1, day => 1, year => $year);
		my $dt = DateTime->new(month => $month + 1, day => $day, year => $year);

		my $row = $dt->weekday_of_month();
		my $first_day_of_month = $start_of_month->day_of_week();
		if(($first_day_of_month < 7) && ($dt->day_of_week() < $first_day_of_month)) {
			$row++;
		}
		$row++;
		my $column = $dt->day_of_week();
		my $dtl = $params{'dtl'};

		if($dtl->first_day_of_week() eq 7) {
			$column++;
			if($column == 8) {
				$column = 1;
				$row++ unless($first_day_of_month == 7);
			}
		}
		die "BUG: row cannot be 8 or greater" if($row >= 8);

		my $table = $params{'table'};

		# print STDERR "$row, $column\n";
		my $str = $table->getCell($row, $column);
		if(index($str, $person->as_string()) != -1) {
			# $printed{$person->xref()} = 1;
			return;
		}
		$str .= '<br>';
		if($opts{'L'}) {
			$str .= '<a href="/' . make_filename_from_person(person => $person) . '">' .
				$person->as_string() .
				'</a>';
		} else {
			$str .= $person->as_string();
		}
		if($aob) {
			if(my $d = $dfg->parse_datetime(date => dateofbirth($person))) {
				$str .= ' b' . $d->strftime('%Y');
			} else {
				red_warning({ person => $person, warning => "Can't parse date of birth '$dob'" });
			}
		}
		if($aod) {
			if(my $d = $dfg->parse_datetime(date => dateofdeath($person))) {
				$str .= ' d' . $d->strftime('%Y');
			} else {
				red_warning({ person => $person, warning => "Can't parse date of death '$dod'" });
			}
		}

		$table->setCell($row, $column, $str);
		# $printed{$person->xref()} = 1;
		return;
	}
	if($ged2 && !defined($ged2->get_individual($person->as_string()))) {
		complain({
			person => $person,
			warning => "not found in $ARGV[1]"
		});
	}

	my $args = {
		include_years => 1,
		middle_names => 1,
		title => 1,
		print_unknown => 1,
	};
	if(!($opts{'A'} || $opts{'G'})) {
		$args->{'nee'} = 1;
	}
	my $text;
	my %places_printed;
	if($opts{'B'}) {
		if($pdfpage->full() || ($pdfpage->linesleft() <= 10)) {
			# Start this person on a new page
			$pdfpage->text()->textend();
			$pdfpage = PDFPage->new();
		} else {
			$pdfpage->newline();
		}
		$text = $pdfpage->text();
		$text->font($params{'font'}, 18);

		$text->translate(25, $pdfpage->newline());
		$text->text($person->as_string($args));

		$text->font($params{'font'}, 12);
	} elsif($opts{'T'}) {
		foreach my $place(get_all_residences($person)) {
			if(my $p = place({ person => $person, record => $place, places_printed => \%places_printed, nopreposition => 1 })) {
				$p =~ s/^\s//;
				push @{$all_places{$p}}, $person;
			}
		}
		for my $event('birth', 'baptism', 'marriage', 'death', 'burial') {
			my $p;
			if(my $r = $person->get_record($event)) {
				$p = place({ person => $person, record => $r, places_printed => \%places_printed, nopreposition => 1 });
			} elsif($p = get_value({ person => $person, value => "$event place" })) {
				$p = place({ person => $person, place => $p, places_printed => \%places_printed, nopreposition => 1 });
			}
			if($p) {
				$p =~ s/^\s//;
				push @{$all_places{$p}}, $person;
			}
		}
		return;
	} else {
		print $person->as_string($args), "\n";
	}

	my $name = $person->name();
	$name =~ s/\///g;
	print "Look at $name\n" if($opts{'v'});
	$nameparser->parse($name);
	my %name_components = $nameparser->components();
	my $firstname = $name_components{'given_name_1'} // $name_components{'initials_1'};
	# my $lastname = $name_components{'surname_2'} || $name_components{'surname_1'};
	my $lastname = ucfirst(lc($person->surname())); # RT109786

	if((!defined($firstname)) && ($name =~ /(.+)\s(.+)/)) {
		$firstname = $1;
		if(!defined($lastname)) {
			$lastname = $2;
		}
		complain({ person => $person, warning => "Can't parse the name - assuming first name: $firstname, last name: $lastname" });
	}

	if($firstname && ($firstname =~ /\d/)) {
		complain({ person => $person, warning => 'First name contains a digit' });
	}
	if($lastname && ($lastname =~ /\d/)) {
		complain({ person => $person, warning => 'Last name contains a digit' });
	}

	my ($marriage_dt, $death_dt);
	my $birth = $person->get_record('birth');

	my $dateofbirth = dateofbirth($person);

	my $placeofbirth = get_value({ person => $person, value => 'birth place' });
	if((!$placeofbirth) && $birth) {
		$placeofbirth = $birth->place();
	}

	if($placeofbirth && ($placeofbirth =~ /[,\.]\s*$/) && ($placeofbirth ne 'U.S.A.')) {
		complain({ person => $person, warning => "Trailing punctuation in birth location '$placeofbirth'" });
		$placeofbirth =~ s/\s*[,\.]\s*$//;
	}

	if($placeofbirth && ($placeofbirth =~ /^,/)) {
		complain({ person => $person, warning => 'Leading comma in birth location' });
		$placeofbirth =~ s/^,\s*//g;
	}

	if($placeofbirth && ($placeofbirth =~ /(.+[a-z]) USA$/)) {
		complain({ person => $person, warning => "Comma missing before USA in birth location '$placeofbirth'" });
		$placeofbirth = "$1, USA";
		$birth_country = 'United States';
	} elsif($placeofbirth && ($placeofbirth =~ /.+,\s?(.+)$/)) {
		my $c = $1;
		if($c eq 'England') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'USA') {
			$birth_country = 'United States';
		} elsif($c eq 'United States of America') {
			$birth_country = 'United States';
		} elsif($c eq 'U.S.A.') {
			$birth_country = 'United States';
		} elsif($c eq 'Scotland') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Wales') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Isle of Man') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Northern Ireland') {
			$birth_country = 'United Kingdom';
		} elsif(($c eq 'Preußen') || ($c eq 'Deutschland')) {	# Prussia
			$birth_country = 'Germany';
		} elsif(($c eq 'Holland') || ($c eq 'The Netherlands')) {
			$birth_country = 'Netherlands';
		} elsif($c eq 'NL') {
			$birth_country = 'Netherlands';
			complain({ person => $person, warning => 'Assuming country of birth is Netherlands' });
		} elsif(($c =~ /[A-Z]{2}/) && ($us->{code2state}{$c})) {
			complain({ person => $person, warning => "$c: assuming country of birth is USA" });
			$birth_country = 'United States';
			$placeofbirth .= ', USA';
		} elsif($us->{state2code}{uc($c)}) {
			complain({ person => $person, warning => "$c: assuming country of birth is USA" });
			$birth_country = 'United States';
			$placeofbirth .= ', USA';
		} elsif(($c =~ /[A-Z]{2}/) && ($ca->{code2province}{$c})) {
			complain({ person => $person, warning => "$c: assuming country of birth is Canada" });
			$birth_country = 'Canada';
			$placeofbirth .= ', Canada';
		} elsif($ca->{province2code}{uc($c)}) {
			complain({ person => $person, warning => "$c: assuming country of birth is Canada" });
			$birth_country = 'Canada';
			$placeofbirth .= ', Canada';
		} elsif(($c =~ /[A-Z]{2,3}/) && ($au->{code2state}{$c})) {
			complain({ person => $person, warning => "$c: assuming country of birth is Australia" });
			$birth_country = 'Australia';
			$placeofbirth .= ', Australia';
		} elsif($au->{state2code}{uc($c)}) {
			complain({ person => $person, warning => "$c: assuming country of birth is Australia" });
			$birth_country = 'Australia';
			$placeofbirth .= ', Australia';
		} elsif(uc($c) eq 'NFLD') {
			complain({ person => $person, warning => 'Assuming country of birth is Canada' });
			$birth_country = 'Canada';
			$placeofbirth .= ', Canada';
		} elsif(($c eq 'Norfolk') || ($c eq 'Kent') || ($c eq 'Sussex') || ($c eq 'Northumberland')) {
			$birth_country = 'United Kingdom';
			complain({ person => $person, warning => 'Assuming country of birth is UK' });
		} elsif($c =~ 'England,?\sUK') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Scot') {
			complain({ person => $person, warning => "$c: birth country should be Scotland'" });
			$birth_country = 'United Kingdom';
		} elsif(my $b = Locale::Object::Country->new(name => $c)) {
			$birth_country = $b->code_alpha2();
		} else {
			complain({ person => $person, warning => "Unknown birth country: '$c' in '$placeofbirth'" });
		}
	}

	my $death = $person->get_record('death');
	my $dateofdeath = dateofdeath($person);
	my $placeofdeath = get_value({ person => $person, value => 'death place' });
	if((!$placeofdeath) && $death) {
		$placeofdeath = $death->place();
	}

	if($placeofdeath && ($placeofdeath =~ /\s\s/)) {
		complain({ person => $person, warning => 'Removing successive spaces from place of death' });
		$placeofdeath =~ s/\s\s+/ /g;
	}

	if($placeofdeath && ($placeofdeath =~ /,\s*$/)) {
		complain({ person => $person, warning => 'Trailing comma in death location' });
		$placeofdeath =~ s/\s*,\s*$//;
	}
	if($placeofdeath && ($placeofdeath =~ /^,/)) {
		complain({ person => $person, warning => 'Leading comma in death location' });
		1 while($placeofdeath =~ s/^,\s*//g);
	}

	if($placeofdeath && ($placeofdeath =~ /(.+[a-z]) USA$/)) {
		complain({ person => $person, warning => "Comma missing before USA in death location '$placeofdeath'" });
		$placeofdeath = "$1, USA";
	} elsif($placeofdeath && ($placeofdeath =~ /.+,\s?(.+)$/)) {
		my $c = $1;
		if($c eq 'England') {
			# $death_country = 'United Kingdom';
		} elsif($c eq 'USA') {
			# $death_country = 'United States';
		# } elsif($c eq 'Texas') {
			# $death_country = 'United States';
		} elsif(($c =~ /[A-Z]{2}/) && ($us->{code2state}{$c})) {
			complain({ person => $person, warning => "$c: assuming country of death is USA" });
			# $death_country = 'United States';
		} elsif($us->{state2code}{uc($c)}) {
			complain({ person => $person, warning => "$c: assuming country of death is USA" });
			# $death_country = 'United States';
		} elsif($c eq 'United States of America') {
			# $death_country = 'United States';
		} elsif($c eq 'U.S.A.') {
			# $death_country = 'United States';
		} elsif($c eq 'Scotland') {
			# $death_country = 'United Kingdom';
		} elsif($c eq 'Scot') {
			complain({ person => $person, warning => "$c: death country should be Scotland'" });
			# $death_country = 'United Kingdom';
		} elsif($c eq 'Wales') {
			# $death_country = 'United Kingdom';
		} elsif(($c eq 'Norfolk') || ($c eq 'Kent') || ($c eq 'Sussex')) {
			# $death_country = 'United Kingdom';
			complain({ person => $person, warning => 'Assuming country of death is UK' });
		} elsif(($c eq 'Nova Scotia') || (uc($c) eq 'NFLD') || ($c eq 'Newfoundland') || ($c eq 'NS')) {
			complain({ person => $person, warning => "Country 'Canada' missing from death record" });
			# $death_country = 'Canada';
		} elsif(($c =~ /[A-Z]{2,3}/) && ($au->{code2state}{$c})) {
			complain({ person => $person, warning => "$c: assuming country of death is Australia" });
			# $death_country = 'Australia';
		} elsif($au->{state2code}{uc($c)}) {
			complain({ person => $person, warning => "$c: assuming country of death is Australia" });
			# $death_country = 'Australia';
		} elsif(($c eq 'Holland') || ($c eq 'The Netherlands')) {
			# $death_country = 'Netherlands';
		} elsif($c eq 'Isle of Man') {
			# $death_country = 'United Kingdom';
		} elsif($c eq 'Northern Ireland') {
			# $death_country = 'United Kingdom';
		} elsif(($c eq 'Preußen') || ($c eq 'Deutschland')) {	# Prussia
			# $death_country = 'Germany';
		} elsif($c =~ /Can\./) {
			complain({ person => $person, warning => 'Assuming country of death is Canada' });
			# $death_country = 'Canada';
		} elsif(my $b = Locale::Object::Country->new(name => $c)) {
			# $death_country = $b->code_alpha2();
		} else {
			complain({ person => $person, warning => "Unknown death country: '$c' in '$placeofdeath'" });
		}
	}

	if($opts{'w'} && $firstname && $lastname) {
		my %chronicling_params = ( ua => $cached_browser );
		if($dateofbirth && ($dateofbirth =~ /(\d{4})$/)) {
			if($1 <= 1789) {
				$chronicling_params{'date_of_birth'} = 1789;
			} else {
				$chronicling_params{'date_of_birth'} = $1;
			}
		}
		if($dateofdeath && ($dateofdeath =~ /(\d{4})$/)) {
			if($1 >= 1963) {
				$chronicling_params{'date_of_death'} = 1963;
			} else {
				$chronicling_params{'date_of_death'} = $1;
			}
		}
		$chronicling_params{'lastname'} = $lastname;
		$chronicling_params{'firstname'} = $firstname;
		my $stateofbirth;
		if($placeofbirth && (($placeofbirth =~ /USA$/) || ($placeofbirth =~ /United States$/)) && ($placeofbirth =~ /^.+,\s*([\w\s]+),[\w\s]+$/)) {
			$stateofbirth = uc($1);
			if($us->{code2state}{$stateofbirth}) {
				$stateofbirth = $us->{code2state}{$stateofbirth};
			} elsif(!$us->{state2code}{$stateofbirth}) {
				complain({ person => $params{'person'}, warning => "Unknown state '$stateofbirth' in birth place $placeofbirth" });
			}
			$chronicling_params{'state'} = ucfirst(lc($stateofbirth));
			chronicling_america($person, \%chronicling_params);

		}
		if($placeofdeath && (($placeofdeath =~ /USA$/) || ($placeofdeath =~ /United States$/)) && ($placeofdeath =~ /^.+,\s*([\w\s]+),[\w\s]+$/)) {
			my $stateofdeath = uc($1);
			if($us->{code2state}{$stateofdeath}) {
				$stateofdeath = $us->{code2state}{$stateofdeath};
			} elsif(!$us->{state2code}{$stateofdeath}) {
				complain({ person => $params{'person'}, warning => "Unknown state '$stateofdeath' in death place $placeofbirth" });
			}
			if((!defined($stateofbirth)) || (lc($stateofdeath) ne lc($stateofbirth))) {
				$chronicling_params{'state'} = ucfirst(lc($stateofdeath));

				# TODO: married and maiden names, could be two searches
				chronicling_america($person, \%chronicling_params);
			}
		}
	}

	my %citations;
	my $citationcount = 0;
	my @birthcitations;
	my @deathcitations;
	if($opts{'c'}) {
		if($birth) {
			if($opts{'w'}) {
				foreach my $s($birth->source()) {
					if(!defined(get_source({ gedcom => $ged, person => $person, source => $s }))) {
						complain({ person => $person, warning => 'Citation is missing a source' });
					}
				}
			}
			my @s = sort { (get_source({ gedcom => $ged, person => $person, source => $a }) && get_source({ gedcom => $ged, person => $person, source => $b })) ? get_source({ gedcom => $ged, person => $person, source => $a })->title() cmp get_source({ gedcom => $ged, person => $person, source => $b })->title() : 0 } $birth->source();
			if(scalar(@s)) {
				my $previous;
				foreach my $src(@s) {
					$src = get_source({ gedcom => $ged, person => $person, source => $src}) unless ref($src);
					if(defined($src) && (my $title = $src->title())) {
						next if($previous && ($title eq $previous));
						$previous = $title;
						push @birthcitations, ++$citationcount;
						$citations{$citationcount} = $src;
					}
				}
			} elsif($opts{'w'}) {
				if($dateofbirth) {
					complain({ person => $person, warning => "Birth date ($dateofbirth) has no citations" });
				} elsif($placeofbirth) {
					complain({ person => $person, warning => "Birth place ($placeofbirth) has no citations" });
				} else {
					complain({ person => $person, warning => 'Birth record has no citations' });
				}
			}
		}
		if($death) {
			my @s = $death->source();
			if(scalar(@s)) {
				foreach my $src(@s) {
					$src = $ged->get_source($src) unless ref($src);
					my $seen;
					foreach my $bc(@birthcitations) {
						if($src eq $citations{$bc}) {
							push @deathcitations, $bc;
							$seen++;
							last;
						}
					}
					if(!$seen) {
						push @deathcitations, ++$citationcount;
						$citations{$citationcount} = $src;
					}
				}
			} elsif($opts{'l'} || !is_alive(person => $person)) {
				if($dateofdeath) {
					# my $dateismissing = 0;
					# my @objects = $person->obje();
					# foreach my $o(@objects) {
						# my $obje;
						# if(ref($o) eq 'Gedcom::Record') {
							# $obje = $o;	# e.g. Ancestry
						# } else {
							# $obje = $ged->resolve_xref($o);	# e.g. FMP
						# }
						# foreach my $item($obje->items()) {
							# next if($item->tag() ne '_DATE');
							# if($item->value() eq $dateofdeath) {
								# $dateismissing = 0;
								# last;
							# }
						# }
					# }
					# if($dateismissing) {
						complain({ person => $person, warning => "Death date ($dateofdeath) has no citations" });
					# }
				} elsif($placeofdeath) {
					complain({ person => $person, warning => "Death place ($placeofdeath) has no citations" });
				} else {
					complain({ person => $person, warning => 'Death record exists with no date or place' });
				}
			}
		}
	}

	my @events = $person->event();

	if(scalar(@events) > 1) {
		my $all_have_dates = 1;
		foreach my $event(@events) {
			if(!ref($event)) {
				$all_have_dates = 0;
				last;
			}
			if(ref($event) ne 'Gedcom::Record') {
				$all_have_dates = 0;
				last;
			}
			if(my $date = $event->date()){
				if(!$dfg->parse_datetime(date => $date)) {
					$all_have_dates = 0;
					last;
				}
			} else {
				$all_have_dates = 0;
				last;
			}
		}
		if($all_have_dates) {
			# print join(' ', map { $_->date() } @events), "\n";
			@events = Sort::Key::DateTime::dtkeysort { $dfg->parse_datetime(date => $_->date()) } @events;
			# print join(' ', map { $_->date() } @events), "\n";
		}
	}

	my $marriage = $person->get_record('marriage') || $person->get_record('fams marriage');
	if((!defined($marriage)) && scalar(@spouses)) {
		$marriage = $spouses[0]->get_record('marriage');
		if((!defined($marriage)) && scalar(@spouses)) {
			if(scalar(@events) == 1) {
				my $event = $person->event();
				if(!ref($event)) {
					my $e = $person->tag_record('EVEN');
					if(ref($e) eq 'Gedcom::Record') {
						$event = $e;
					}
				}
				if((ref($event) eq 'Gedcom::Record') &&
				  ($event->type() eq 'Custom Marriage')) {
					# FindMyPast
					$marriage = $event;
				}
			} else {
				foreach my $event(@events) {
					if((ref($event) eq 'Gedcom::Record') &&
					  ($event->type() eq 'Custom Marriage')) {
						# FindMyPast
						$marriage = $event;
						last;
					}
				}
			}
		}
	}

	my $birth_dt = date_to_datetime(date => $dateofbirth);

	if($birth_dt && (my $spouse = $spouses[0])) {
		my $sdob = dateofbirth($spouse);
		if($sdob && (my $sbirth_dt = date_to_datetime(date => $sdob))) {
			if($sbirth_dt > ($birth_dt + $fortyyears)) {
				complain({
					person => $person,
					warning => 'Spouse born more than 40 years after date of birth'
				});
			} elsif($birth_dt > ($sbirth_dt + $fortyyears)) {
				complain({
					person => $person,
					warning => 'Born more than 40 years after date of birth of spouse'
				});
			}
		}
	}

	my $dateofmarriage = get_value({ person => $person, value => 'marriage date' });
	if((!$dateofmarriage) && $marriage) {
		$dateofmarriage = $marriage->date();
	}
	if($dateofmarriage && ($dateofmarriage =~ /\d$/)) {
		$marriage_dt = date_to_datetime(date => $dateofmarriage);
	}

	if($birth_dt && $marriage_dt && $opts{'w'} && ($marriage_dt < ($birth_dt + $sixteenyears))) {
		complain({
			person => $person,
			warning => 'married when less than 16 years old'
		});
	}

	$death_dt = date_to_datetime(date => $dateofdeath);

	if($opts{'d'} || $opts{'B'}) {
		my $baptism = $person->get_record('baptism');
		my $dateofbaptism = get_value({ person => $person, value => 'baptism date' });
		if((!$dateofbaptism) && $baptism) {
			$dateofbaptism = $baptism->date();
		}
		my $placeofbaptism = get_value({ person => $person, value => 'baptism place' });
		if((!$placeofbaptism) && $baptism) {
			$placeofbaptism = $baptism->place();
		}

		my $placeofmarriage = get_value({ person => $person, value => 'marriage place' });
		if((!$placeofmarriage) && $marriage) {
			$placeofmarriage = $marriage->place();
		}
		if($placeofmarriage && ($placeofmarriage =~ /.+,\s?(.+)$/)) {
			my $c = $1;
			if($c eq 'Scot') {
				complain({ person => $person, warning => "$c: marriage country should be Scotland'" });
				$placeofmarriage .= 'land';
			}
		}

		my $burial;
		my $dateofburial;
		my $placeofburial;
		my $cremation;
		my $dateofcremation;
		my $placeofcremation;
		if($burial = $person->get_record('burial')) {
			$dateofburial = get_value({ person => $person, value => 'burial date' });
			if(!$dateofburial) {
				$dateofburial = $burial->date();
			}
			$placeofburial = get_value({ person => $person, value => 'burial place' });
			if(!$placeofburial) {
				$placeofburial = $burial->place();
			}
		} elsif($cremation = $person->get_record('cremation')) {
			$dateofcremation = get_value({ person => $person, value => 'cremation date' });
			if(!$dateofcremation) {
				$dateofcremation = $cremation->date();
			}
			$placeofcremation = get_value({ person => $person, value => 'cremation place' });
			if(!$placeofcremation) {
				$placeofcremation = $cremation->place();
			}
		}

		my $marriagecitation;
		my @burialcitations;
		if($opts{'c'}) {
			if($marriage) {
				if(my $src = $marriage->source()) {
					$src = $ged->get_source($src) unless ref($src);
					# FIXME:  Only looks for matches in the first citations
					if(!defined($src)) {
						complain({
							person => $person,
							warning => [ "marriage citation can't find source ", $marriage->source() ]
						});
					} elsif($birthcitations[0] && ($citations{$birthcitations[0]} eq $src)) {
						$marriagecitation = $birthcitations[0];
					} elsif($birthcitations[1] && ($citations{$birthcitations[1]} eq $src)) {
						$marriagecitation = $birthcitations[1];
					} elsif($deathcitations[0] && ($citations{$deathcitations[0]} eq $src)) {
						$marriagecitation = $deathcitations[0];
					} else {
						$marriagecitation = ++$citationcount;
						$citations{$marriagecitation} = $src;
					}
				} elsif($opts{'w'}) {
					if($dateofmarriage) {
						red_warning({ person => $person, warning => "Marriage date ($dateofmarriage) has no citations" });
					} elsif($placeofmarriage) {
						red_warning({ person => $person, warning => "Marriage place ($placeofmarriage) has no citations" });
					} else {
						red_warning({ person => $person, warning => 'Marriage record has no citations' });
					}
				}
			}
			if($burial) {
				my @s = $burial->source();
				if(scalar(@s)) {
					foreach my $src(@s) {
						$src = $ged->get_source($src) unless ref($src);
						if(!defined($src)) {
							complain({
								person => $person,
								warning => [ "burial citation can't find source ", $burial->source() ]
							});
							next;
						}
						my $seen;
						foreach my $dc(@deathcitations) {
							if($src eq $citations{$dc}) {
								push @burialcitations, $dc;
								$seen++;
								last;
							}
						}
						if(!$seen) {
							if($marriagecitation && ($citations{$marriagecitation} eq $src)) {
								push @burialcitations, $marriagecitation;
							} else {
								push @burialcitations, ++$citationcount;
								$citations{$citationcount} = $src;
							}
						}
					}
				} elsif($opts{'w'}) {
					if($dateofburial) {
						complain({ person => $person, warning => "Burial date ($dateofburial) has no citations" });
					} elsif($dateofcremation) {
						complain({ person => $person, warning => "Cremation date ($dateofcremation) has no citations" });
					} elsif($placeofburial) {
						complain({ person => $person, warning => "Burial place ($placeofburial) has no citations" });
					} else {
						complain({ person => $person, warning => "Cremation place ($placeofcremation) has no citations" });
					}
				}
			}
		}

		my $pronoun = $person->pronoun();
		if($language eq 'French') {
			$pronoun = ($pronoun eq 'He') ? 'Il' : 'Elle';
		}
		my $sex = $person->sex();

		if($opts{'w'} && $firstname && $sex) {
			# FIXME: This throws up a number of false positives
			my $guess;
			if($placeofbirth && ($placeofbirth =~ /, USA$/)) {
				$guess = Text::Names::guessGender($firstname);
			} else {
				$guess = Text::Names::GB::guessGender($firstname);
			}
			if($guess && ($sex ne $guess)) {
				my $error = 1;
				if(my $middle_name = $name_components{'middle_name'}) {
					if($placeofbirth && ($placeofbirth =~ /, USA$/)) {
						$guess = Text::Names::guessGender($middle_name);
					} else {
						$guess = Text::Names::GB::guessGender($middle_name);
					}
					if($guess && ($sex eq $guess)) {
						$error = 0;
					}
				}
				if($error) {
					complain({ person => $person, warning => 'Check the gender of the record' });
				}
			}
		}
		my @children = map { $_->children() } $person->fams();
		my $numberofchildren = scalar(@children);

		if($opts{'w'} && $numberofchildren) {
			foreach my $child(@children) {
				if($child->xref() eq $person->xref()) {
					complain({ person => $person, warning => 'person is own parent' });
					# Avoid loops in G::I::Relationship
					return;
				}
			}
		}

		my $relationship;
		my $spouserelationship;
		my $spouse;

		if($dateofbirth && $opts{'w'} && scalar(@siblings)) {
			foreach my $sibling(@siblings) {
				if(($sibling->name() eq $person->name()) || Text::Names::samePerson($sibling->name(), $person->name())) {
					my $siblingbirth = dateofbirth($sibling);
					if($siblingbirth && ($siblingbirth eq $dateofbirth)) {
						complain({ person => $sibling, warning => 'possible duplicate person' });
					} elsif((!$dateofdeath) && !dateofdeath($sibling)) {
						complain({ person => $sibling, warning => 'two siblings of the same name alive at the same time'});
					}
				}
			}
		}

		if($me && ($person->xref() ne $me->xref()) && !$opts{'G'}) {
			$relationship = $me->relationship($person);
			if((!$relationship) && scalar(@spouses)) {
				if($person->spouse() eq $me) {
					if($language eq 'French') {
						$relationship = ($sex eq 'F') ? 'femme' : 'mari';
					} else {
						$relationship = ($sex eq 'F') ? 'wife' : 'husband';
					}
				} else {
					foreach my $s(@spouses) {
						$spouserelationship = $me->relationship($s);
						if($spouserelationship) {
							$spouse = $s;
							last;
						}
					}
				}
			}
			if((!$relationship) && (!$spouserelationship)) {
				complain({
					person => $person,
					warning => "Can't find relationship with the home person"
				});
			}
		}

		my @occupations = get_all_occupations(person => $person);

		my $same_occupation_as_father;
		my $printed_comma = 0;

		my $bio = "\t";

		if($occupations[0]) {
			my @foccupations;
			if($father) {
				@foccupations = get_all_occupations(person => $father);
			}
			if(scalar(@foccupations) && ($occupations[0] eq $foccupations[0])) {
				$same_occupation_as_father = $occupations[0];
				@occupations = ();
			} else {
				$bio .= 'A';
				if($occupations[0] =~ /^[aeiou]/i) {
					$bio .= 'n';
				}
				$bio .= ' ';
				if($occupations[1]) {
					# my $alloccupations = join(', ', @occupations);
					# substr($alloccupations, rindex($alloccupations, ', '), 2, ' and ');
					# print lc($alloccupations);
					$bio .= lc(Lingua::EN::Inflect::WORDLIST(@occupations, {final_sep => ''}));
				} else {
					$bio .= lc($occupations[0]);
				}
				if(!($father || $mother || $spouserelationship)) {
					$bio .= ', ';
					$printed_comma = 1;
				}
			}
		}

		my @twins;
		if($birth_dt) {
			foreach my $s(@siblings) {
				if(my $dob = dateofbirth($s)) {
					if(($dob =~ /^\d/) && ($dob !~ /[a-z]$/i)) {
						my $d;
						eval {
							$d = $date_parser->parse(date => $dob);
						};
						if($d) {
							$d = @{$d}[0];
						}
						if($d) {
							$d = $dfn->parse_datetime($d->{'canonical'});
							if(($d == $birth_dt) || ($d == ($birth_dt - $oneday)) || ($d == ($birth_dt + $oneday))) {
								push @twins, $s;
							}
						}
					}
				}
			}
			if(scalar(@twins) == 1) {	# TODO triplets and higher order
				if(scalar(@occupations)) {
					$bio .= ', twin of ' . $twins[0]->given_names();
				} else {
					$bio .= 'The twin ' . (($person->sex() eq 'M') ? 'brother' : 'sister') .
						' of ' . $twins[0]->given_names();
				}
			}
		}

		my $print_sibling_count = 0;

		if($father || $mother) {
			if(scalar(@occupations) || scalar(@twins)) {
				$bio .= ' and the ';
			} else {
				$bio .= 'The ';
			}

			if($birth_dt) {
				if(scalar(@siblings)) {
					# If possible, sort siblings by date of birth
					my $all_siblings_have_dob = 1;
					foreach my $sibling(@siblings) {
						if(my $dob = dateofbirth($sibling)) {
							if(($dob !~ /^\d/) || ($dob =~ /[a-z]$/i) ||
							   ($dob =~ /[\/\-]/) || !date_parser_cached(date => $dob)) {
								$all_siblings_have_dob = 0;
								last;
							}
							my $d;
							eval {
								$d = $date_parser->parse(date => $dob);
							};
							if($d) {
								$d = @{$d}[0];
							}
							if($@ || !defined($d)) {
								complain({
									person => $sibling,
									warning => "has an invalid date of birth: $dob"
								});
								$all_siblings_have_dob = 0;
								last;
							}
						} else {
							$all_siblings_have_dob = 0;
							last;
						}
					}
					if($all_siblings_have_dob) {
						@siblings = Sort::Key::DateTime::dtkeysort { $dfn->parse_datetime(@{$date_parser->parse(date => dateofbirth($_))}[0]->{'canonical'}) } @siblings;
					}
					my $age_index = 1;	# count of siblings born before $person + 1 (i.e. where $person is in the date order)
					$print_sibling_count = 1;
					foreach my $sibling(@siblings) {
						if(my $dob = dateofbirth($sibling)) {
							if(my $d = date_parser_cached(date => $dob)) {
								$d = $dfn->parse_datetime($d->{'canonical'});
								if($opts{'w'} &&
								  ($dob =~ /^\d/) && ($dob !~ /[a-z]$/i) &&
								  ($d < $birth_dt) &&
								  ($d < ($birth_dt - $oneday)) &&
								  ($d > ($birth_dt - $tenmonths))) {
									complain({
										person => $sibling,
										warning => 'Born less than 10 months before sibling ' . $person->as_string()
									});
								}
								$age_index++ if($d && ($d < $birth_dt));
							} else {
								$all_siblings_have_dob = 0;
								last;
							}
						} else {
							$all_siblings_have_dob = 0;
							last;
						}
					}
					if($all_siblings_have_dob) {
						if(scalar(@siblings) && ($age_index == (scalar(@siblings) + 1))) {
							$bio .= ((scalar(@siblings) > 1) ? 'youngest' : 'younger');
						} elsif(scalar(@siblings) && ($age_index == 1)) {
							$bio .= ((scalar(@siblings) > 1) ? 'eldest' : 'older');
						} else {
							$bio .= ordinate($age_index);
						}
						$bio .= ' of ' . (scalar(@siblings) + 1) . ' children';
					} else {
						$bio .= 'child';
					}
				} else {
					# print ' only child of';
					$bio .= 'child';
				}
			} else {
				$bio .= 'child';
			}

			$bio .= ' of';

			if($father) {
				$bio .= ' ' . $father->as_string();
				if(!$same_occupation_as_father) {
					my @occupations = get_all_occupations(person => $father);
					# TODO: print all occupations
					if(my $occupation = $occupations[0]) {
						$occupation = lc($occupation);
						if($language eq 'English') {
							if($ENV{'LANG'} =~ /^en_US/) {
								$occupation = Lingua::EN::ABC::b2a($occupation);
							} elsif($ENV{'LANG'} =~ /^en_CA/) {
								$occupation = Lingua::EN::ABC::b2c($occupation);
							} else {
								$occupation = Lingua::EN::ABC::a2b($occupation);
							}
						}
						$bio .= ' (' . Lingua::EN::Inflect::A($occupation) . ')';
					}
				}
				if($mother) {
					if($language eq 'French') {
						$bio .= ' et';
					} else {
						$bio .= ' and';
					}
				} else {
					$bio .= ', ';
					$printed_comma = 1;
				}
			}
			if($mother) {
				if(my $m = $mother->as_string(give_maidenname => 0)) {
					$bio .= " $m";
				}
				my @occupations = get_all_occupations($mother);
				# TODO: print all occupations
				if($occupations[0]) {
					$bio .= ' (' . Lingua::EN::Inflect::A(lc($occupations[0])) . ')';
				}
				if($opts{'w'} && $birth_dt && (my $mdod = dateofdeath($mother))) {
					if(my $dt = date_to_datetime(date => $mdod)) {
						if($birth_dt > $dt) {
							complain({ person => $person, warning => 'Born after mother died' });
						}
					}
				}
			}
			if(($aob || $dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism || scalar(@spouses) || $relationship) && ($occupations[0])) {
				$bio .= ', ';
				$printed_comma = 1;
			}
			if($language eq 'French') {
				$bio =~ s/^\tThe child of\s/\tL'enfant de /;
				$bio =~ s/\sand the child of\s/ et l'enfant de /;
			}
		}

		my $haveprintedspousename;
		if($relationship) {
			if($father || $mother || $occupations[0]) {
				if($aob || $aod || $dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism || scalar(@spouses)) {
					$bio .= ', ' unless($printed_comma);
				} elsif(is_alive(person => $person)) {
					$bio .= $person->as_string() . ' is ';
				} else {
					if($opts{'p'} || $opts{'a'}) {
						$bio .= ', ' unless($printed_comma);
					}
					if($language eq 'French') {
						$bio .= $person->as_string() . ' était ';
					} else {
						$bio .= $person->as_string() . ' was ';
					}
				}
				if($language eq 'French') {
					$bio .= 'votre';
				} else {
					$bio .= 'your';
				}
			} elsif($language eq 'French') {
				$bio .= 'Votre';
			} else {
				$bio .= 'Your';
			}
			$bio .= " $relationship";
		} elsif($spouserelationship) {
			if($father || $mother || $occupations[0]) {
				$bio .= ', ' unless($printed_comma);
				if($firstname) {
					$bio .= $firstname;
				} else {
					$bio .= $pronoun;
				}
				$bio .= ', ';
			} else {
				$bio .= $person->as_string();
				if($aob || $aod || $dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism || $dateofmarriage) {
					$bio .= ', ';
				} elsif(is_alive(person => $person)) {
					if($language eq 'French') {
						$bio .= ' est ';
					} else {
						$bio .= ' is ';
					}
				} else {
					if($language eq 'French') {
						$bio .= ' était ';
					} else {
						$bio .= ' was ';
					}
				}
			}
			if($language eq 'French') {
				if($sex eq 'F') {
					$bio .= 'la femme';
				} else {
					$bio .= 'le mari';
				}
			} else {
				if($sex eq 'F') {
					$bio .= 'the wife';
				} else {
					$bio .= 'the husband';
				}
			}
			if($language eq 'French') {
				$bio .= " de votre $spouserelationship";
			} else {
				$bio .= " of your $spouserelationship";
			}
			if(my $s = $spouse->as_string({ middle_names => 1, title => 1 })) {
				$bio .= " $s";
			} else {
				complain({ person => $spouse, warning => 'Seems to have no name' });
			}
			if($aob || $aod || $dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism || $dateofmarriage) {
				$bio .= ',';
			}
			$haveprintedspousename = 1;
		} elsif(($mother || $father) && ($dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism || $dateofmarriage) && !$printed_comma) {
			$bio .= ', ';
		}

		if(($dateofbaptism || $placeofbaptism) && !($mother || $father) && $relationship) {
			complain({ person => $person, warning => 'Baptism information not used to determine a parent' });
		}

		if(!$spouserelationship) {
			if($aob || $dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism || scalar(@spouses)) {
				if($relationship) {
					$bio .= ' ';
				}
				if($firstname) {
					$bio .= $firstname;
				} else {
					$bio .= $pronoun;
				}
			}
		}

		if(my $aka = $person->as_string({ use_aka => 1 })) {
			$bio .= " (also known as $aka)";
		}

		my $end_of_sentence = 0;
		if($aob && $aod) {
			if($aob == $aod) {
				$bio .= " was born and died $aod years ago ";
			} else {
				$bio .= " was born $aob years and died $aod years ago ";
			}
			$bio .= ($opts{'t'} ? 'tomorrow' : 'today');
			$bio .= "[$_]" foreach(@birthcitations);
			$bio .= "[$_]" foreach(@deathcitations);
			$bio .= '. ';
			$end_of_sentence = 1;
		} elsif($aob) {
			if($language eq 'French') {
				$bio .= ' est né';
				if($sex eq 'F') {
					$bio .= 'e';
				}
				$bio .= " il y a $aob " . (($aob == 1) ? 'an' : 'ans');
				if($opts{'t'}) {
					$bio .= ' demain';
				}
			} else {
				$bio .= " was born $aob " . (($aob == 1) ? 'year' : 'years') . ' ago ' .
					($opts{'t'} ? 'tomorrow' : 'today');
			}
			if($placeofbirth) {
				my $p = place({ person => $person, record => $birth, places_printed => \%places_printed, encode => 0 });
				$bio .= $p;
				$places_printed{$p} = 1;
			} else {
				complain({ person => $person, warning => 'Date of birth is known, but not place' });
			}
			$bio .= "[$_]" foreach(@birthcitations);
			$bio .= '. ';
			$end_of_sentence = 1;
		} elsif($aod) {
			if($language eq 'French') {
				$bio .= ' est mort';
				if($sex eq 'F') {
					$bio .= 'e';
				}
				$bio .= " il y a $aod " . (($aod == 1) ? 'an' : 'ans');
				if($opts{'t'}) {
					$bio .= ' demain';
				}
			} else {
				$bio .= " died $aod " . (($aod == 1) ? 'year' : 'years') . ' ago ' .
					($opts{'t'} ? 'tomorrow' : 'today');
			}
			if($placeofdeath) {
				$bio .= place({ person => $person, record => $death, places_printed => \%places_printed });
			}
			$bio .= "[$_]" foreach(sort @deathcitations);
			if($death && (my $notes = notes({ person => $person, record => $death, paragraph => 0 }))) {
				$notes =~ s/\.$//;
				$notes = lcfirst($notes) unless($notes =~ /^[A-Z]{2}/);
				$bio .= " ($notes).";
				if(length($notes) > 160) {
					$bio .= "\n\t";
				} else {
					$bio .= ' ';
				}
			} else {
				$bio .= '. ';
			}
			$end_of_sentence = 1;
		}

		my @residences = get_all_residences($person);
		print scalar(@residences), " residences found\n" if($opts{'v'});

		if((!$aob) && ($dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism)) {
			$bio .= " $pronoun" if($aob || $aod);
			if($dateofbirth || $placeofbirth) {
				$bio .= ',' if($print_sibling_count && (!$opts{'a'}) && (!$aob) && (!$aod) && !$opts{'p'});
				my $birth_place;
				if($placeofbirth) {
					if($aod && $placeofdeath && ($placeofbirth eq $placeofdeath) && !$death->address()) {
						if($language eq 'French') {
							$bio .= ' y';
						} else {
							$birth_place = ' there';
						}
					} else {
						$birth_place = place({ person => $person, place => $placeofbirth, places_printed => \%places_printed });
					}
				} else {
					complain({ person => $person, warning => 'Date of birth is known, but not place' });
				}

				if($language eq 'French') {
					$bio .= ' est ';
					$bio .= ($sex eq 'M' ? 'né' : 'née');
				} else {
					$bio .= ' was born';
				}
				$bio .= $birth_place if($birth_place);

				if($dateofbirth) {
					my $y = year({
						person => $person,
						date => $dateofbirth,
						must_predate => $death_dt
					});
					if($y =~ /^fro?m (.+) to (.+)/i) {
						$y = "between $1 and $2";
					}
					$bio .= " $y" if($y);
				}
				$bio .= "[$_]" foreach(@birthcitations);
				if($opts{'w'}) {
					if($mother && $yob && (my $mumdateofbirth = dateofbirth($mother))) {
						if($mumdateofbirth =~ /.*?(\d{3,4})/) {
							$mumdateofbirth = $1;
							if(($yob - $mumdateofbirth) <= 13) {
								complain({
									person => $person,
									warning => "Something is wrong with the date of birth which is less than 13 years after the mother was born ($mumdateofbirth)"
								});
							} elsif(($yob - $mumdateofbirth) >= 52) {
								complain({
									person => $person,
									warning => "Something is wrong with the date of birth which is more than 52 years after the mother was born ($mumdateofbirth)"
								});
							}
						}
					}
					if($father && $yob && (my $daddateofbirth = dateofbirth($father))) {
						if($daddateofbirth =~ /.*?(\d{3,4})/) {
							$daddateofbirth = $1;
							if(($yob - $daddateofbirth) <= 13) {
								complain({
									person => $person,
									warning => "Something is wrong with the date of birth which is less than 13 years after the father was born ($daddateofbirth)"
								});
							}
						}
					}
					if($death_dt || ($dateofdeath && ($dateofdeath =~ /^\d{3,4}$/))) {
						# TODO: Add more checking
						my $yod;
						if($death_dt) {
							$yod = $death_dt->year();
						} elsif($dateofdeath =~ /^(\d{3,4})$/) {
							$yod = $1;
						} else {
							die "BUG: Impossible case";
						}
						foreach my $bc(@birthcitations) {
							my $citation = $citations{$bc};
							my $title = $citation->title();
							if($title =~ /^(\d{3,4})\s/) {
								if($1 > $yod) {
									complain({
										person => $person,
										warning => "Year of citation of $title is after the death year of $yod"
									});
								}
							}
						}
					}
				}
				if($dateofbaptism || $placeofbaptism) {
					if(scalar(@spouses) && ($aod || $aob) && ($numberofchildren > 0) && !($opts{'a'} || $opts{'p'})) {
						if($language eq 'French') {
							$bio .= ', était';
						} else {
							$bio .= ', was';
						}
					} elsif($language eq 'French') {
						$bio .= ' et';
					} else {
						$bio .= ' and';
					}
				} elsif($birth_dt) {
					my @twins;
					foreach my $s(@siblings) {
						if(my $dob = dateofbirth($s)) {
							if(($dob =~ /^\d/) && ($dob !~ /[a-z]$/i)) {
								my $d;
								eval {
									$d = $date_parser->parse(date => $dob);
								};
								if($d) {
									$d = @{$d}[0];
								}
								if($d) {
									$d = $dfn->parse_datetime($d->{'canonical'});
									if(($d == $birth_dt) || ($d == ($birth_dt - $oneday)) || ($d == ($birth_dt + $oneday))) {
										push @twins, { sibling => $s, dob => $d };
									}
								}
							}
						}
					}
					if(scalar(@twins) == 1) {	# TODO triplets and higher order
						my $t = $twins[0];
						my $sibling = $t->{'sibling'};
						my $dob = $t->{'dob'};
						if($dob == $birth_dt) {
							$bio .= ', the same day as ';
						} elsif($dob == ($birth_dt + $oneday)) {
							$bio .= ', a day before ';
						} else {
							$bio .= ', a day after ';
						}
						$bio .= ($sex eq 'M' ? 'his' : 'her') . ' twin ' .
							(($sibling->sex() eq 'F') ? 'sister, ' : 'brother, ') .
							$sibling->given_names();
					}
				}
				$end_of_sentence = 0;
			}
			if($dateofbaptism || $placeofbaptism) {
				$bio .= ' ';
				unless($dateofbirth || $placeofbirth) {
					if($language eq 'French') {
						$bio .= 'était ';
					} else {
						$bio .= 'was ';
					}
				}
				if($ENV{'LANG'} =~ /^en_US/) {
					$bio .= 'baptized';
				} else {
					$bio .= 'baptised';
				}
				if($placeofbaptism) {
					if(($aod || $opts{'a'} || $opts{'p'}) && $placeofbirth && ($placeofbaptism eq $placeofbirth)) {
						$bio .= ' there';
						if(my $address = $baptism->address()) {
							if($address =~ /(.+),\s*$placeofbirth$/) {
								$address = $1;
							}
							$bio .= " at $address";
						}
					} else {
						my $p = place({ person => $person, place => $placeofbaptism });
						$bio .= $p;
						$places_printed{$p} = 1;
					}
				}
				if($dateofbaptism) {
					if($opts{'w'} && $yob && ($dateofbaptism =~ /(\d{3,4})$/)) {
						# must_predate doesn't work when only years are known
						if($1 < $yob) {
							complain({
								person => $person,
								warning => "Year of baptism $1 is before the year of birth $yob"
							});
						}
					}
					$bio .= ' ' . year({
						person => $person,
						date => $dateofbaptism,
						must_postdate => $birth_dt,
						must_predate => $death_dt
					});
					if(!$death_dt) {
						must_predate({
							person => $person,
							date => $dateofbaptism,
							predate => $dateofdeath
						});
					}
					$bio .= print_sibling_baptism({
						person => $person,
						siblings => \@siblings,
						date => $dateofbaptism,
						birthdate => $dateofbirth,
					});
					if($mother && $opts{'w'}) {
						if($dateofbaptism =~ /.*?(\d{3,4})/) {
							my $yobaptism = $1;
							if(my $motherdob = dateofbirth($mother)) {
								my $d = $date_parser->parse(date => $motherdob);
								if($d && (ref($d) eq 'ARRAY')) {
									$d = @{$d}[0];
									if(defined($d) && !$d->{'flag'}) {
										$d = $dfn->parse_datetime($d->{'canonical'})->strftime('%Y');
										if($d > ($yobaptism - 13)) {
											complain({
												person => $person,
												warning => "Something is wrong with the date of baptism which is less than 13 years after the mother was born ($d)"
											});
										}
									}
								}
							}
						} else {
							complain({
								person => $person,
								warning => "invalid date of baptism $dateofbaptism"
							});
							$warned{$person} = 1;
						}
					}
				}
				$end_of_sentence = 0;
			}
			if(scalar(@spouses) && ($aod || $aob) && ($numberofchildren > 0)) {
				# $bio .= ' and';
			} else {
				$bio .= '. ';
				$end_of_sentence = 1;
			}
		} elsif($aob && ($dateofbaptism || $placeofbaptism)) {
			if($language eq 'French') {
				$bio .= " $pronoun était ";
			} else {
				$bio .= " $pronoun was ";
			}

			if($ENV{'LANG'} =~ /^en_US/) {
				$bio .= 'baptized';
			} else {
				$bio .= 'baptised';
			}
			if($placeofbaptism) {
				if($placeofbirth && ($placeofbaptism eq $placeofbirth)) {
					if($aod) {
						$bio .= ' in ' .
							lcfirst($person->possessive()) .
							' home town';
					} else {
						$bio .= ' there';
						if(my $address = $baptism->address()) {
							$bio .= " at $address";
						}
					}
				} else {
					my $opts = {
						person => $person,
						place => $placeofbaptism,
						places_printed => \%places_printed
					};
					if(my $address = $baptism->address()) {
						$opts->{'address'} = $address;
					}
					my $p = place($opts);
					$bio .= $p;
					$places_printed{$p} = 1;
				}
			}
			if($dateofbaptism) {
				$bio .= ' ' . year({
					person => $person,
					date => $dateofbaptism,
					must_postdate => $birth_dt,
					must_predate => $death_dt
				});
				$bio .= print_sibling_baptism({
					person => $person,
					siblings => \@siblings,
					date => $dateofbaptism,
					birthdate => $dateofbirth,
				});
			}
			if(scalar(@spouses)) {
				if(!scalar(@residences)) {
					$bio .= ',';
				}
				$end_of_sentence = 0;
			} else {
				$bio .= '. ';
				$end_of_sentence = 1;
			}
		}

		my $all_children_are_alive = 1;

		if($yob && ($year >= $yob + 150)) {
			$all_children_are_alive = 0;
		} else {
			foreach my $child(@children) {
				if(!is_alive(person => $child)) {
					$all_children_are_alive = 0;
					last;
				}
			}
		}

		my @education = $person->education();

		if(scalar(@education)) {
			if($end_of_sentence) {
				$bio .= " $pronoun";
			} elsif($language eq 'French') {
				$bio .= ' et';
			} else {
				$bio .= ' and';
			}
			if($language eq 'French') {
				# FIXME: remove space after à l'
				$bio .= ' est' . (($sex eq 'M' ? 'allé' : 'allée')) .
					(($education[0] =~ /^[aehiou]/i) ? ' à l' : ' au');
			} else {
				$bio .= ' went to';
			}
			# FIXME: do all schools
			$bio .= place({ person => $person, record => $education[0], places_printed => \%places_printed, nopreposition => 1 }) .
				'. ';
			$end_of_sentence = 1;
		}

		my @childrenunknownparent;
		# TODO: children != 0 && spouses == 0
		if(scalar(@spouses) &&
		   ((!$spouserelationship) || $placeofmarriage || $dateofmarriage)) {
			$bio .= " $pronoun" if($end_of_sentence);

			if(scalar(@spouses) == 1) {
				if((!$end_of_sentence) &&
				   ((scalar(@residences) > 0) || ((!($dateofbaptism)) && !$placeofbaptism))) {
					if($language eq 'French') {
						$bio .= ' et';
					} else {
						$bio .= ' and';
					}
				}
				if($placeofmarriage || $dateofmarriage) {
					if($placeofbaptism && $placeofmarriage && ($placeofmarriage eq $placeofbaptism) &&
					   !$end_of_sentence) {
						$bio .= ' also';
					}
					if($language eq 'French') {
						$bio .= ' est marié';
						if($sex eq 'F') {
							$bio .= 'e';
						}
						$bio .= ' ';
					} else {
						$bio .= ' married ';
					}
				} elsif(is_alive(person => $person) && is_alive(person => $spouses[0])) {
					if($language eq 'French') {
						if($sex eq 'M') {
							$bio .= ' est mariée à ';
						} else {
							$bio .= ' est marié à ';
						}
					} else {
						$bio .= ' is married to ';
					}
				} else {
					if($language eq 'French') {
						if($sex eq 'M') {
							$bio .= ' était mariée à ';
						} else {
							$bio .= ' était marié à ';
						}
					} else {
						$bio .= ' was married to ';
					}
				}
				if($haveprintedspousename) {
					$nameparser->parse($spouses[0]->name());

					my %name_components = $nameparser->components();
					if(my $n = $name_components{'given_name_1'}) {
						$bio .= $n;
					} else {
						complain({ person => $spouses[0], warning => 'seems to have no first name' });
					}
				} else {
					$bio .= $spouses[0]->as_string();
					$haveprintedspousename = 1;
				}
				my $parentheses = 0;
				if($numberofchildren) {
					my @spouse_occupations = get_all_occupations($spouses[0]);
					if(my $soccupation = $spouse_occupations[0]) {
						$parentheses = 1;
						$bio .= ' (' .
							Lingua::EN::Inflect::A(lc($soccupation)) .
							' ';
					}
					my @childrenofthisspouse;
					my $numberofchildrenwiththisspouse = $numberofchildren;
					my $spouse = $spouses[0];
					foreach my $child(@children) {
						if($sex eq 'F') {
							# Check through all possible fathers, since there could be a biologial and
							# and adoptive one listed
							# FIXME: this assumes that the spouse is the biological father, which is not
							#	a good assumption to make
							my @candidates = $child->father();
							my $father;
							foreach (@candidates) {
								if($_ eq $spouse) {
									$father = $_;
									last;
								}
							}
							if((!defined($father)) || ($father ne $spouse)) {
								push @childrenunknownparent, $child;
								$numberofchildrenwiththisspouse--;
							} else {
								push @childrenofthisspouse, $child;
							}
						} else {
							my $mother = $child->mother();
							if((!defined($mother)) || ($mother ne $spouse)) {
								push @childrenunknownparent, $child;
								$numberofchildrenwiththisspouse--;
							} else {
								push @childrenofthisspouse, $child;
							}
						}
					}
					if(scalar(@childrenunknownparent) < $numberofchildren) {
						if(!$parentheses) {
							$bio .= ' (';
							$parentheses = 1;
						}
						$bio .= 'with whom ' . lcfirst($pronoun);
						if((!$all_children_are_alive) || (!$opts{'l'}) || ($yob && ($year > $yob + 100))) {
							$bio .= ' had ';
						} elsif((!$dateofdeath) && (!$dateofburial) && ($spouses[0]) && !$spouses[0]->death()) {
							$bio .= ' has had ';
						} else {
							$bio .= $dateofdeath || $dateofburial ? ' had ' : ' has ';
						}

						if($numberofchildrenwiththisspouse == 1) {
							if($all_children_are_alive) {
								$bio .= '1 surviving child, ';
							} elsif($language eq 'French') {
								$bio .= '1 enfant, ';
							} else {
								$bio .= '1 child, ';
							}
						} else {
							if($all_children_are_alive) {
								$bio .= "$numberofchildrenwiththisspouse surviving children: ";
							} elsif($language eq 'French') {
								$bio .= "$numberofchildrenwiththisspouse enfants: ";
							} else {
								$bio .= "$numberofchildrenwiththisspouse children: ";
							}
						}
						if($numberofchildrenwiththisspouse == 1) {
							$bio .= $children[0]->given_names();
						} elsif($numberofchildrenwiththisspouse > 1) {
							# my $childnames = join(', ', map { $_->given_names() } @children);
							# substr($childnames, rindex($childnames, ', '), 2, ' and ');
							# print $childnames;
							if($language eq 'French') {
								$bio .= Lingua::EN::Inflect::WORDLIST((map { $_->given_names() } @childrenofthisspouse), {final_sep => '', conj => 'et'});
							} else {
								$bio .= Lingua::EN::Inflect::WORDLIST((map { $_->given_names() } @childrenofthisspouse), {final_sep => ''});
							}
						}
					}
				} else {
					my @spouse_occupations = get_all_occupations($spouses[0]);
					if($spouse_occupations[0]) {
						$bio .= ' (' . Lingua::EN::Inflect::A(lc($spouse_occupations[0]));
						$parentheses = 1;
					}
				}
				if($parentheses) {
					$bio .= ')';
				} elsif(($dateofmarriage || $placeofmarriage) && $numberofchildren) {
					$bio .= ',';
				}
				if($placeofmarriage && $dateofmarriage &&
				   (($placeofbaptism and ($placeofmarriage eq $placeofbaptism)) ||
				    ($aod && $placeofbirth && ($placeofmarriage eq $placeofbirth)))) {
					if((!defined($placeofbaptism)) or ($placeofmarriage ne $placeofbaptism)) {
						$bio .= ' there';
					}
					$bio .= ' ';
					if(my $address = $marriage->address()) {
						if($address eq 'Parish Church') {
							$bio .= 'at the Parish Church ';
						} elsif($address eq 'Registry Office') {
							$bio .= 'at the Registry Office ';
						} else {
							$bio .= "at $address ";
						}
					}
					$bio .= year(person => $person, string => $dateofmarriage, must_postdate => $birth_dt, must_predate => $death_dt);
				} else {
					$bio .= ' ' . year(person => $person, string => $dateofmarriage, must_postdate => $birth_dt, must_predate => $death_dt) if($dateofmarriage);
					if($placeofmarriage) {
						my $args = {
							place => $placeofmarriage,
							person => $person,
							places_printed => \%places_printed
						};
						if($marriage && (my $address = $marriage->address())) {
							$args->{'address'} = $address;
						}
						my $p = place($args);
						$bio .= $p;
						$places_printed{$p} = 1;
					}
				}
				$bio .= "[$marriagecitation]" if($marriagecitation);
			} else {
				if(!$end_of_sentence) {
					if($language eq 'French') {
						$bio .= ' et';
					} else {
						$bio .= ' and';
					}
				}
				if(is_alive(person => $person)) {
					$bio .= ' has been married ';
				} else {
					$bio .= ' was married ';
				}
				if(scalar(@spouses) == 2) {
					if($spouses[0] eq $spouses[1]) {
						complain({ person => $person, warning => [ 'Married twice to ', $spouses[0]->as_string() ] });
					} else {
						$bio .= 'twice';
					}
				} else {
					$bio .= scalar(@spouses) . ' times';
				}
				my $all_marriages_have_date = 1;
				foreach my $spouse(@spouses) {
					my $date = get_value({ person => $spouse, value => 'marriage date' });
					if(!defined($date)) {
						if(my $marriage = ($spouse->get_record('marriage') || $spouse->get_record('fams marriage'))) {
							$date = $marriage->date();
						}
					}
					if(!date_to_datetime($date)) {
						$all_marriages_have_date = 0;
						last;
					}
				}
				if($all_marriages_have_date) {
					@spouses = Sort::Key::DateTime::dtkeysort {
						my $date;
						if(my $rec = $_->get_record('fams marriage')) {
							$date = $rec->date();
						}
						if((!defined($date)) && (my $rec = $_->get_record('marriage'))) {
							$date = $rec->date();
						}
						date_to_datetime(date => $date);
					} @spouses;
				}
				my $names;
				my $spouse_number = 0;
				my $previousplace;
				foreach my $spouse(@spouses) {
					# $names .= ', ' if($names);
					$names .= $spouse->as_string();
					my $dateofmarriage = get_value({ person => $spouse, value => 'marriage date' });
					if(!defined($dateofmarriage)) {
						if(my $marriage = ($spouse->get_record('marriage') || $spouse->get_record('fams marriage'))) {
							$dateofmarriage = $marriage->date();
						}
					}
					my $placeofmarriage = get_value({ person => $spouse, value => 'marriage place' });
					if(!defined($placeofmarriage)) {
						if(my $marriage = $spouse->get_record('marriage') || $spouse->get_record('fams marriage')) {
							$placeofmarriage = $marriage->place();
						}
					}
					if($placeofmarriage) {
						$placeofmarriage = place({ person => $spouse, place => $placeofmarriage, places_printed => \%places_printed });
						if($previousplace && ($placeofmarriage eq $previousplace)) {
							if($placeofmarriage =~ /^(.+?),/) {
								$placeofmarriage = " also$1";
							}
						} else {
							$previousplace = $placeofmarriage;
						}
					}

					my $printed_bracket = 0;
					if($dateofmarriage && $placeofmarriage) {
						$names .= ' (' . year({ string => $dateofmarriage }) .
							$placeofmarriage;
						$printed_bracket = 1;
					} elsif($placeofmarriage) {
						$placeofmarriage =~ s/^\s+//;
						$names .= " ($placeofmarriage";
						$printed_bracket = 1;
					} elsif($dateofmarriage) {
						$names .= ' (' . year({ string => $dateofmarriage });
						$printed_bracket = 1;
					}
					$spouse_number++;
					if((scalar(@spouses) == 2) && $all_marriages_have_date && ($spouse_number == 2) &&
					   (my $death_of_first_spouse = dateofdeath($spouses[0]))) {
						if(datecmp($dateofmarriage, $death_of_first_spouse) > 0) {
							if($printed_bracket) {
								$names .= ', ';
							} else {
								$names .= '(';
								$printed_bracket = 1;
							}
							$names .= 'following the death of ' .
								$spouses[0]->as_string() . ' ' .
								year({
									person => $spouses[0],
									record => $death_of_first_spouse,
								});
						}
					}
					$names .= ')' if($printed_bracket);
					if($spouse_number == (scalar(@spouses) - 1)) {
						$names .= ' and ';
					} elsif($spouse_number < (scalar(@spouses) - 1)) {
						$names .= ', ';
					}
				}
				# substr($names, rindex($names, ', '), 2, ' and ');
				$bio .= ", to $names";
				$bio .= "[$marriagecitation]" if($marriagecitation);

				# Determine if all the children are from one marriage, since that's
				# easier to print.
				# FIXME:  handle where offspring are from more than one marriage
				if($numberofchildren) {
					my %childrenbyspouse;
					my $childrenseen = 0;
					my $unknown;
					foreach my $family ($person->fams()) {
						if($family->number_of_children() &&
						   ($spouse = ($sex eq 'M') ? $family->wife() : $family->husband())) {
							foreach my $child($person->children()) {
								$unknown = $child;
								foreach my $spouseschild($spouse->children()) {
									if($spouseschild eq $child) {
										$childrenbyspouse{$spouse}++;
										$childrenseen++;
										$unknown = undef;
										last;
									}
								}
							}
						}
					}
					my $parentofall;
					if($childrenseen < $numberofchildren) {
						# Unable to find the parent of all of the children.  This
						# may be the case where someone married more than once,
						# and has a child by a 3rd unknown (or unfound) person
						if($opts{'w'}) {
							if(($numberofchildren - $childrenseen) == 1) {
								if($unknown) {
									complain({ person => $person, warning => 'One of the parents of ' . $unknown->as_string() . ' is not known'});
								} else {
									complain({ person => $person, warning => 'One of the parents of 1 child is not known'});
								}
							} else {
								complain({ person => $person, warning => 'One of the parents of ' . ($numberofchildren - $childrenseen) . ' children is not known'});
							}
						}
					} else {
						foreach my $spouse(@spouses) {
							if($parentofall && $childrenbyspouse{$spouse}) {
								$parentofall = undef;
								last;
							}
							if($childrenbyspouse{$spouse}) {
								$parentofall = $spouse;
							}
						}
					}
					$bio .= ".  $pronoun " .
						($all_children_are_alive ? 'has ' : 'had ');
					if($numberofchildren == 1) {
						if($all_children_are_alive) {
							$bio .= '1 surviving child';
						} elsif($language eq 'French') {
							$bio .= '1 enfant';
						} else {
							$bio .= '1 child';
						}
						if($childrenseen >= $numberofchildren) {
							if($parentofall) {
								if($language eq 'French') {
									$bio .= ' avec ' . $parentofall->as_string();
								} else {
									$bio .= ' with ' . $parentofall->as_string();
								}
							} else {
								complain({ person => $person, warning => 'BUG: parentofall not set when only one child' });
							}
						} else {
							$bio .= ' with an unknown ' . (($sex eq 'M') ? 'mother' : 'father');
						}
						$bio .= ', ' . $children[0]->given_names();
					} else {
						if($all_children_are_alive) {
							$bio .= "$numberofchildren surviving children";
						} elsif($language eq 'French') {
							$bio .= "$numberofchildren enfants";
						} else {
							$bio .= "$numberofchildren children";
						}
						my $childnames;
						if($parentofall) {
							if($numberofchildren == 2) {
								$bio .= ', both with ' . $parentofall->as_string();
							} else {
								$bio .= ', all with ' . $parentofall->as_string();
							}
							$childnames = join(', ', map { $_->given_names() } @children);
						} elsif($sex eq 'M') {
							# FIXME: children from the same parent should be listed together
							$childnames = join(', ', map { $_->given_names() . ($_->mother() ? (' (with ' . $_->mother()->given_names() . ')') : '') } @children);
						} else {
							$childnames = join(', ', map { $_->given_names() . ($_->father() ? (' (with ' . $_->father()->given_names() . ')') : '') } @children);
						}
						substr($childnames, rindex($childnames, ', '), 2, ' and ');
						$bio .= ": $childnames";
					}
				}
			}
			if($bio =~ /\.$/) {
				$end_of_sentence = 1;
			} else {
				$end_of_sentence = 0;
			}
		} elsif($numberofchildren) {
			# Neither date nor place of marriage is known
			if($end_of_sentence) {
				$bio .= " $pronoun";
			} elsif(scalar(@residences) == 0) {
				if($language eq 'French') {
					$bio .= ' et';
				} else {
					$bio .= ' and';
				}
			}
			$bio .= ' had ';
			if($language eq 'French') {
				$bio .= (($numberofchildren == 1) ? '1 enfant, ' : "$numberofchildren enfants, ");
			} else {
				$bio .= (($numberofchildren == 1) ? '1 child, ' : "$numberofchildren children, ");
			}
			if($numberofchildren == 1) {
				$bio .= $children[0]->given_names();
			} else {
				my $childnames = join(', ', map { $_->given_names() } @children);
				substr($childnames, rindex($childnames, ', '), 2, ' and ');
				$bio .= $childnames;
			}
			$end_of_sentence = 0;
		}

		if(scalar(@childrenunknownparent)) {
			$bio .= '.  ' if(!$end_of_sentence);
			$bio .= "$pronoun ";
			if(scalar(@children) > scalar(@childrenunknownparent)) {
				$bio .= 'also ';
			}
			$bio .= 'had ' . scalar(@childrenunknownparent) . ' ';
			if(scalar(@childrenunknownparent) == 1) {
				$bio .= 'child, ';
			} else {
				$bio .= 'children, ';
			}
			$bio .= Lingua::EN::Inflect::WORDLIST((map { $_->given_names() } @childrenunknownparent), {final_sep => ''}) .
				', whose ' .
				(($sex eq 'F') ? 'father' : 'mother') .
				' is unknown';
			$end_of_sentence = 0;
		}

		if($same_occupation_as_father) {
			$bio .= '. ' if(!$end_of_sentence);
			$bio .= ' Like ' . lcfirst($person->possessive()) . ' father, ' . lcfirst($pronoun) .
				(is_alive(person => $person) ? ' is' : ' was');
			$bio .= ' ' . Lingua::EN::Inflect::A(lc($same_occupation_as_father)) . '. ';
			$end_of_sentence = 1;
		}

		my $printed_residence = 0;
		my %citationnotes;

		if($opts{'w'}) {
			my $index = 0;
			foreach my $event(@events) {
				$index++;
				if(!ref($event)) {
					my $e = $person->tag_record('EVEN', $index);
					if(ref($e) eq 'Gedcom::Record') {
						$event = $e;
					} else {
						red_warning({ person => $person, warning => "Event record is just description ($event), infomation has been lost" });
					}
				}
				if(ref($event) eq 'Gedcom::Record') {
					my $type = $event->type();
					if(!defined($type)) {
						red_warning({ person => $person, warning => "Can't determine type of event, or the event type is empty" });
						next;
					}

					# if(($type =~ /^Census U[KS] \d{4}$/) || ($type eq 'Register UK 1939')) {
					if(($type =~ /Census/) || ($type eq 'Register UK 1939')) {
						if(!$dateofbirth) {
							complain({ person => $person, warning => 'Census information not used to approximate a date of birth' });
						}
					}
				}
			}
		}

		my $diedathome;

		if(scalar(@residences)) {
			# FIXME: handle duplicate locations better
			my @residencelist;
			my %residencecitations;

			# This is an attempt to handle
			# https://github.com/pjcj/Gedcom.pm/issues/13
			my $index = 0;
			foreach my $residence(@residences) {
				$index++;
				if(!ref($residence)) {
					my $r = $person->tag_record('EVEN', $index);
					if(ref($r) eq 'Gedcom::Record') {
						$residence = $r;
					} else {
						$r = $person->record(['residence', $index]);
						if(ref($r) eq 'Gedcom::Record') {
							$residence = $r;
						} else {
							red_warning({ person => $person, warning => "Residence record is just description ($residence), infomation has been lost" });
						}
					}
				}
				if(ref($residence) eq 'Gedcom::Record') {
					my $place = $residence->place();
					if(my $address = $residence->address()) {
						if(ref($address) eq 'Gedcom::Record') {
							$place = getaddress($address);
						} elsif($place) {
							$place = "$address, $place";
						} else {
							complain({
								person => $person,
								warning => "address set to $address but place is empty"
							});
						}
					}
					if(defined($place)) {
						if(my $dor = $residence->date()) {
							if($placeofbirth && $dob && ($dor eq $dob)) {
								next;
							}
							if($placeofmarriage && $dateofmarriage && ($dor eq $dateofmarriage)) {
								next;
							}
						}
						push @residencelist, $residence;
						if($opts{'c'}) {
							if(my $src = $residence->source()) {
								$src = get_source({ gedcom => $ged, person => $person, source => $src}) unless ref($src);
								my $note = notes(record => $residence);
								foreach my $c(@birthcitations) {
									if($src eq $citations{$c}) {
										$residencecitations{$residence} = $c;
										if($note) {
											$citationnotes{$c} = $note;
										}
										last;
									}
								}
								unless($residencecitations{$residence}) {
									if($deathcitations[0] && ($src eq $citations{$deathcitations[0]})) {
										$residencecitations{$residence} = $deathcitations[0];
										if($note) {
											$citationnotes{$deathcitations[0]} = $note;
										}
									} else {
										$residencecitations{$residence} = ++$citationcount;
										$citations{$citationcount} = $src;
										if($note) {
											$citationnotes{$citationcount} = $note;
										}
									}
								}
							} elsif(my $dor = $residence->date()) {
								red_warning({ person => $person, warning => "Residence record for $dor contains no citation" });
							}
						}
					} elsif(my $dor = $residence->date()) {
						if(my $type = $residence->type()) {
							if(($type ne 'Military service') &&
							   ($type ne 'Story')) {
								red_warning({ person => $person, warning => "Residence record for $dor contains no location" });
							}
						} else {
							red_warning({ person => $person, warning => 'Residence record contains no type' });
						}
					} else {
						red_warning({ person => $person, warning => 'Residence record contains no date' });
					}
				}
			}

			if(scalar(@residencelist) == 2) {
				print "Check if the residences are the same\n" if($opts{'v'});
				my $date1 = $residencelist[0]->date();
				my $date2 = $residencelist[1]->date();

				if($date1 && $date2 && ($date1 eq $date2)) {
					if(places_are_the_same({ person => $person, first => $residencelist[0], second => $residencelist[1] })) {
						complain({ person => $person, warning => "Duplicate residence on $date1" });
						@residencelist = ($residencelist[0]);
					}
				}
			}
			# TODO: See RT110333

			# Sort residences chronologically
			# FIXME: This messes citations
			my $all_residences_have_date = 1;
			foreach my $residence(@residencelist) {
				my $date = $residence->date();
				if(!$date) {
					complain({ person => $person, warning => 'Contains a residence' . place(record => $residence) . ' without a date' });
					$all_residences_have_date = 0;
					last;
				}
				$date = $date_parser->parse(date => $date);
				if(!defined($date)) {
					complain({ person => $person, warning => "Can't parse date '$date'" });
					$all_residences_have_date = 0;
					last;
				}
				if(scalar(@{$date}) == 0) {
					# e.g. "Apr/May/Jun 2016"
					$all_residences_have_date = 0;
					last;
				}
			}
			if($all_residences_have_date) {
				print "Sort the residences\n" if($opts{'v'});
				@residencelist = Sort::Key::DateTime::dtkeysort { $dfn->parse_datetime(@{$date_parser->parse(date => $_->date())}[0]->{'canonical'}) } @residencelist;
			}
			my $count = 0;
			my $prev_residence;
			my $spdeath_dt;
			if($spouses[0] && ($spdeath_dt = dateofdeath($spouses[0]))) {
				$spdeath_dt = date_to_datetime(date => $spdeath_dt);
			}
			my $print_year_only;	# used when printing a range, e.g. 1871-1891
			my $printed_following_message;
			my %printed_dates;

			my @residencestringarray;

			# Create a list of residence strings
			foreach my $residence(@residencelist) {
				my $rdate = $residence->date();
				my $latitude;
				my $longitude;
				my $residencestring;
				if(($count == 0) || !places_are_the_same({ person => $person, first => $residence, second => $residencelist[$count - 1] })) {
					if($birth && $dob && $rdate && ($rdate eq $dob) &&
					   places_are_the_same({ person => $person, first => $birth, second => $residence})) {
						# This residence record is for the place of birth, which is
						# printed elsewhere
						$count++;
						next;
					}
					if($birth && places_are_the_same({ person => $person, first => $birth, second => $residence})) {
						$residencestring = ' at ' . ($person->pronoun() eq 'She' ? 'her' : 'his')
								. ' birthplace';
					} else {
						my $p = place({
							person => $person,
							record => $residence,
							places_printed => \%places_printed
						});
						if($residence->type() && ($residence->type() eq 'Hospitalisation')) {
							$residencestring = ' in hospital';
						}

						if((!defined($prev_residence)) ||
						   !places_are_the_same({ person => $person, first => $prev_residence, second => $residence })) {
							# Actually prints the place here
							$residencestring .= $p;
							$places_printed{$p} = 1;
						}
					}
					if($rdate && (my $rdate_dt = date_to_datetime($rdate))) {
						my $year = $rdate_dt->year();
						my $strftime = $rdate_dt->strftime('%x');
						my $place = place({
							person => $person,
							record => $residence,
						});
						if($place) {
							$place =~ s/^\s(at|in)\s//;
							my @locations = $geocoder->geocode($place);
							if(defined($locations[0]->{geometry}{location}{lat}) && !defined($locations[0]->{'error'})) {
								$latitude = $locations[0]->{geometry}{location}{lat};
								$longitude = $locations[0]->{geometry}{location}{lng};
								push @{$all_locations{$year}}, {
									'residence' => $residence,
									'person' => $person,
									'date' => $strftime,
									'latitude' => $latitude,
									'longitude' => $longitude,
								};
							}
						}
						if($opts{'w'} && $marriage_dt && ($rdate_dt > $marriage_dt)) {
							if(!defined($spouses[0])) {
								complain({ person => $person, warning => 'Has a date of marriage but no spouse' });
							} else {
								# Check this person was living at the same place as their spouse.
								# TODO: Also check all children under 10
								foreach my $l(@{$all_locations{$year}}) {
									if(($l->{'person'} eq $spouses[0]) &&
									   ($l->{'date'} eq $strftime)) {
										my $r1 = place(record => $residence, nopreposition => 1);
										my $r2 = place(record => $l->{'residence'}, nopreposition => 1);
										if($r1 ne $r2) {
											$r1 =~ s/^\s+//;
											$r2 =~ s/^\s+//;
											complain({
												person => $person,
												warning => [
													"$strftime: not living at same address as spouse ",
													$spouses[0]->as_string(),
													" ('$r1'/'$r2')"
												]
											});
										}
									}
								}
							}
						}
					}
				}
				# Citation residence notes print later
				if($rdate) {	# residence has a date?
					next if($printed_dates{$rdate});
					$printed_dates{$rdate}++;
					if($opts{'w'} && ($rdate =~ /(\d{3,4})$/)) {
						my $yoe = $1;
						if($yod) {
							if($yoe > $yod) {
								complain({
									person => $person,
									warning => "Year of residence $yoe is after the year of death $yod"
								});
							} elsif($death_dt && (my $rdate_dt = date_to_datetime($rdate))) {
								# FIXME: If $rdate is a date range, should check both dates in the range
								if($rdate_dt > $death_dt) {
									complain({
										person => $person,
										warning => "Date of residence $rdate is after date of death " . $death_dt->strftime('%x')
									});
								}
							}
						}
						# Check if spouse listed at all residences when we only know the year
						if($spouses[0]) {
							my $spyod = dateofdeath($spouses[0]) || ($yoe + 1);
							if($spyod =~ /(\d{3,4})$/) {
								$spyod = $1;
							}
							if(defined($dateofmarriage) &&
							   ($dateofmarriage =~ /(\d{3,4})$/) &&
							   (my $spouse = $spouses[0]) &&
							   ($yoe < $spyod)) {
								my $yom = $1;
								if($yom < $yoe) {
									my $found_spouse;
									foreach my $residence(get_all_residences($spouse)) {
										my $date = $residence->date();
										if(defined($date) && ($date =~ /(\d{3,4})$/)) {
											if($1 == $yoe) {
												$found_spouse = $residence;
												last;
											}
										}
									}
									if(!$found_spouse) {
										complain({ person => $person, warning => ["Listed in the residence for $rdate, but spouse ", $spouse->as_string(), ' is not'] });
									}
								}
							}
						}
						if($yob && (($yoe - $yob) <= 10)) {
							my $found_parent = 0;
							if($mother) {
								foreach my $m_residence(get_all_residences($mother)) {
									my $date = $m_residence->date();
									if(defined($date) && ($date =~ /(\d{3,4})$/)) {
										if($1 == $yoe) {
											$found_parent = $m_residence;
											my $p1 = place({
													person => $mother,
													record => $m_residence,
													nopreposition => 1
												});
											my $p2 = place({
													person => $person,
													record => $residence,
													nopreposition => 1
												});
											if($p1 ne $p2) {
												$p1 =~ s/^\s+//;
												$p2 =~ s/^\s+//;
												complain({ person => $person, warning => "Location for $date ($p2) differs from mother's ($p1)" });
											}
											if($date ne $rdate) {
												complain({ person => $person, warning => "Date of residence ($rdate) differs from mother's in same year ($date)" });
											}
											last;
										}
									}
								}
							}
							if($father && ($opts{'w'} || !$found_parent)) {
								foreach my $f_residence(get_all_residences($father)) {
									my $date = $f_residence->date();
									if(defined($date) && ($date =~ /(\d{3,4})$/)) {
										if($1 == $yoe) {
											$found_parent = $f_residence;
											my $p1 = place({
													person => $father,
													record => $f_residence,
													nopreposition => 1
												});
											my $p2 = place({
													person => $person,
													record => $residence,
													nopreposition => 1
												});
											if($p1 ne $p2) {
												$p1 =~ s/^\s+//;
												$p2 =~ s/^\s+//;
												complain({ person => $person, warning => "Location for $date ($p2) differs from father's ($p1)" });
											}
											if($date ne $rdate) {
												complain({ person => $person, warning => "Date of residence ($rdate) differs from father's in same year ($date)" });
											}
											last;
										}
									}
								}
							}
							if((!$mother) && !$father) {
								# People not related by blood tend not to have been researched
								if($relationship) {
									complain({ person => $person, warning => 'Census information not used to determine a parent' });
								}
							} elsif(!$found_parent) {
								# FIXME: both parents could be dead
								complain({ person => $person, warning => "Residence information in $yoe, but no residence information found for either parent" });
							}	# TODO: else warn if both parents locations are different
						} elsif($numberofchildren && ($rdate !~ /^bet\s/i)) {
							# Look if a young child isn't with this parent
							foreach my $child(@children) {
								my $cyob = dateofbirth($child);
								next if(!defined($cyob));
								next if(datecmp($cyob, $rdate) >= 0);	# Child was not born yet
								if($cyob =~ /(\d{3,4})\s*$/) {
									$cyob = $1;
								}
								next if(($yoe - $cyob) > 10);	# Over 10 years old
								if(my $cyod = dateofdeath($child)) {
									next if(datecmp($cyod, $rdate) <= 0);	# Child was dead by this event
								}

								my $missing_child = 1;
								foreach my $event(get_all_residences($child)) {
									my $edate = $event->date();
									if($edate && ($edate !~ /^bet\s/i) && (datecmp($edate, $rdate) >= 0)) {
										$missing_child = 0;
										last;
									}
								}
								if($missing_child) {
									if($firstname) {
										complain({ person => $child, warning => "Parent $firstname is listed in the residence for $rdate, but this child is not" });
									} else {
										complain({ person => $child, warning => "Parent is listed in the residence for $rdate, but this child is not" });
									}
								}
							}
						}
					}
					if(scalar(@residencelist) > 1) {
						my $this_date = year({ person => $person, date => $rdate });
						if($prev_residence && (year(record => $prev_residence) eq $this_date)) {
							if(place(record => $prev_residence) ne place(record => $residence)) {
								complain({ person => $person, warning => "Two residence records for $rdate differ in location" });
							}
						} else {
							if($print_year_only) {
								if($count == (scalar(@residencelist) - 1)) {
									$residencestring .= $rdate;
									# $print_year_only = 0;
								}
							} else {
								if((!defined($residencestring)) && (my $p = pop(@residencestringarray))) {
									$p =~ s/ and /, /g;
									$residencestring = "$p and $this_date";
								} else {
									$residencestring .= " $this_date";
								}
							}
							$prev_residence = $residence;
						}
					}
					if(defined($latitude)) {
						# Print close relatives living close by
						# This really only works when printing a lot of people, for example with the -a
						#	flag, or when producing a PDF book, since it relies on having found data
						#	on people beforehand
						my $year = date_to_datetime($rdate)->year();
						my $printed_person = 0;
						my $gis = GIS::Distance->new('MathTrig');
						my $p2 = place({ record => $residence, nopreposition => 1 });
						my $count = 0;
						my $p3;	# previous place
						my @people_at_p3;

						my @sorted_locations = sort { $a->{'latitude'} <=> $b->{'latitude'} } @{$all_locations{$year}};

						# $Data::Dumper::Maxdepth = 2;
						foreach my $l(@sorted_locations) {
							$count++;
							# print Data::Dumper->new([$l])->Dump();
							if(($l->{'person'}->xref() ne $person->xref()) &&
							   (($spouses[0] && ($l->{'person'}->xref() eq $spouses[0]->xref())) ||
							   (my $relationship = $person->relationship($l->{'person'})) &&
							    ((stepsabove($l->{'person'}, $person, 0) <= 3) &&
							     (stepsabove($person, $l->{'person'}, 0) <= 3)))) {
								my $distance = $gis->distance($l->{'latitude'}, $l->{'longitude'}, $latitude, $longitude);
								my $peek = $sorted_locations[$count];
								next if($peek && ($peek->{'person'} eq $l->{'person'}));
								my $p1 = place({ record => $l->{'residence'}, nopreposition => 1});
								# print "p1: $p1\n\tp2 $p2\n";
								if($p1 eq $p2) {
									if($p3 && $peek && (place({ record => $peek->{'residence'}, nopreposition => 1 }) eq $p3)) {
										if((!defined($people_at_p3[0])) || ($people_at_p3[0]->{'person'} ne $l->{'person'})) {
											push @people_at_p3, $l;
										}
										next;
									}
									$p3 = $p1;
								} elsif(($l->{'latitude'} == $latitude) && ($l->{'longitude'} == $longitude)) {
									complain({
										person => $person,
										warning => [ $l->{'person'}->as_string(nee => 1), " residence is same location probably should be recorded as the same address ('$p1'/'$p2') in $year" ]
									});
								} elsif($distance->yards() < 20) {
									complain({
										person => $person,
										warning => [ $l->{'person'}->as_string(nee => 1), " residence is very close probably should be recorded as the same address ('$p1'/'$p2') in $year" ]
									});
								} elsif($distance->miles() < 1) {
									if($p3 && $peek && (place({ record => $peek->{'residence'}, nopreposition => 1 }) eq $p3)) {
										if((!defined($people_at_p3[0])) || ($people_at_p3[0]->{'person'} ne $l->{'person'})) {
											push @people_at_p3, $l;
										}
										next;
									}
									$p3 = $p1;
									if($printed_person) {
										$residencestring .= ', ';
									} else {
										$residencestring .= ', less than a mile from ';
									}
									if($spouses[0] && ($l->{'person'}->xref() eq $spouses[0]->xref())) {
										# FIXME: Only when before they married, though when
										#	they are married it should be the same place, right?
										if($language eq 'French') {
											$residencestring .= (($sex eq 'M') ? 'sa futur femme ' : 'son futur mari ');
										} else {
											$residencestring .= (($sex eq 'M') ? 'his future wife ' : 'her future husband ');
										}
									} else {
										$residencestring .= ($sex eq 'M' ? 'his' : 'her') .
											" $relationship ";
									}
									$residencestring .= $l->{'person'}->as_string();
									if(scalar(@people_at_p3)) {
										while(my $p = pop(@people_at_p3)) {
											if(scalar(@people_at_p3)) {
												$residencestring .= ',';
											} elsif($language eq 'French') {
												$residencestring .= ' et';
											} else {
												$residencestring .= ' and';
											}
											$residencestring .= ' ' .
												$person->relationship($p->{'person'}) .
												' ' .
												$p->{'person'}->as_string();
										}
										if($language eq 'French') {
											$residencestring .= ' qui habitaient';
										} else {
											$residencestring .= ' who were living';
										}
									} else {
										if($language eq 'French') {
											$residencestring .= ' qui habitait';
										} else {
											$residencestring .= ' who was living';
										}
									}
									$residencestring .= place({ record => $l->{'residence'}, there => $p2 });
									$printed_person = 1;
								}
							} elsif(($mother || $father) && defined($birth_dt) && ref($birth_dt)) {
								# FIXME - we should be able to calculate rough age from $yob
								my $bdiff = $dfn->parse_datetime($rdate) - $birth_dt;
								my $raddress = $residence->address();
								if(defined($raddress) && ($bdiff->in_units('years') >= 30)) {
									my $living_with_mother;
									my $living_with_father;
									if($raddress =~ /,\s*(.+)/) {
										$raddress = $1;
									}
									if($raddress =~ /^\d*\s(.+)/) {
										$raddress = $1;
									}
									if($mother) {
										my @mr = get_all_residences(person => $mother);
										foreach my $mr(@mr) {
											next unless ($mr->place() eq $residence->place());
											my $address = $mr->address();
											next unless defined($address);
											if(my $d = $mr->date()) {
												next if($d ne $rdate);
												if($address =~ /,\s*(.+)/) {
													$address = $1;
												}
												if($raddress =~ /^\d*\s(.+)/) {
													$raddress = $1;
												}
												if($raddress eq $address) {
													$living_with_mother++;
													last;
												}
											}
										}
									}
									if($father) {
										my @fr = get_all_residences(person => $father);
										foreach my $fr(@fr) {
											next unless ($fr->place() eq $residence->place());
											my $address = $fr->address();
											next unless defined($address);
											if(my $d = $fr->date()) {
												next if($d ne $rdate);
												if($address =~ /,\s*(.+)/) {
													$address = $1;
												}
												if($raddress =~ /^\d*\s(.+)/) {
													$raddress = $1;
												}
												if($raddress eq $address) {
													$living_with_father++;
													last;
												}
											}
										}
									}
									if($living_with_mother || $living_with_father) {
										$residencestring .= ', when ' . lcfirst($pronoun) .
													' was living on the same road as ' .
													($person->pronoun() eq 'She' ? 'her' : 'his');
										if($living_with_mother && $living_with_father) {
											$residencestring .= ' parents';
										} elsif($living_with_mother) {
											$residencestring .= ' mother';
										} else {
											$residencestring .= ' father';
										}
										$printed_person = 1;
									}
								}
							}
						}
						$residencestring .= ',' if($printed_person);
					}
					if($spdeath_dt && (!$printed_following_message) && (my $rdate_dt = date_to_datetime($rdate))) {
						if($rdate_dt > $spdeath_dt) {
							# Living with a child following death of spouse?
							CHILD: foreach my $child(@children) {
								my @cevents = $child->event();
								my $index = 0;
								EVENT: foreach my $event(@cevents) {
									$index++;
									if(!ref($event)) {
										my $e = $child->tag_record('EVEN', $index);
										if(ref($e) eq 'Gedcom::Record') {
											$event = $e;
										} else {
											# red_warning({ person => $child, warning => "Event record is just description ($event), infomation has been lost" });
											next EVENT;
										}
									}
									my $type = $event->type();

									# if(($type !~ /^Census U[KS] \d{4}$/) && ($type ne 'Register UK 1939')) {
									if(($type !~ /Census/) && ($type ne 'Register UK 1939')) {
										next EVENT;
									}
									if((ref($event) eq 'Gedcom::Record') &&
									   $event->date() && ($event->date() eq $rdate) &&
									   places_are_the_same({ person => $child, first => $residence, second => $event })) {
										$residencestring .= ' when ' .
											lcfirst($person->pronoun()) .
											' was living with ' .
											lcfirst($person->possessive()) .
											(($child->sex() eq 'F') ? ' daughter, ' : ' son, ') .
											$child->given_names() .
											', following the death of ' .
											(($sex eq 'M') ? 'his wife ' : 'her husband ') .
											year(date => dateofdeath($spouses[0]));
										$spdeath_dt = undef;
										last CHILD;
									}
								}
							}
							if($spdeath_dt) {
								# Outlived spouse, but not living with a child
								$residencestring .= ' following the death of ' .
									($person->pronoun() eq 'She' ? 'her' : 'his') .
									(($sex eq 'M') ? ' wife ' : ' husband ') .
									year(date => dateofdeath($spouses[0]));
							}
							$printed_following_message = 1;
						}
					}
					# Find if they are an adult living with an adult sibling or in-law
					if($all_residences_have_date && scalar(@siblings) && $birth_dt) {
						my $printed_sibling = 0;
						my $r = $residence;
						next if($r->date() ne $rdate);
						my $place = place({ person => $person, record => $r });
						my $first = 1;

						my $bdiff = $dfn->parse_datetime($rdate) - $birth_dt;

						foreach my $sibling(@siblings) {
							if(my $ss = $sibling->spouse()) {
								next if($bdiff->in_units('years') < 20);
								# If they are living with an in-law, assume both are adults
								my @ssr = get_all_residences(person => $ss);
								foreach my $ssr(@ssr) {
									if(my $d = $ssr->date()) {
										next if($d ne $rdate);

										# Compare only if full addresses to prevent
										# false positives when only a city is known
										if(($place =~ /^d/ && (my $ssp = place({ person => $ss, record => $ssr })))) {
											if($ssp eq $place) {
												if($first) {
													$residencestring .= ' when ' . ($person->pronoun() eq 'She' ? 'her' : 'his') .
													' was living with ' . ($person->pronoun() eq 'She' ? 'her ' : 'his ') .
														(($ss->sex() eq 'F') ? 'sister-in-law, ' : 'brother-in-law, ') .
														$ss->as_string();
														$first = 0;
												} elsif($language eq 'French') {
													$residencestring .= ' et ' .
														(($ss->sex() eq 'F') ? 'belle-sœer, ' : 'beau-frère, ') .
														$ss->as_string();
												} else {
													# FIXME: If possible, should say
													#	sisters-in-law or
													#	brothers-in-law
													$residencestring .= ' and ' .
														(($ss->sex() eq 'F') ? 'sister-in-law, ' : 'brother-in-law, ') .
														$ss->as_string();
												}
												$printed_sibling = 1;
												# May be removed later
		if($language eq 'French') {
													$residencestring .= ' et';
												} else {
													$residencestring .= ' and';
												}
												last;
											}
										}
									}
								}
							}
							next if($bdiff->in_units('years') < 40);
							# Safe to assume both are adults at this time
							my @sr = get_all_residences(person => $sibling);
							foreach my $sr(@sr) {
								my $sdate = $sr->date();
								next if(!defined($sdate));
								next if($sdate ne $rdate);
								if(($place =~ /^\d/) && (place({ person => $sibling, record => $sr }) eq $place)) {
									if($first) {
										$residencestring .= ' with ' . ($person->pronoun() eq 'She' ? 'her' : 'his');
										$first = 0;
									}
									$residencestring .= ' ' .
										(($sibling->sex() eq 'F') ? 'sister, ' : 'brother, ') .
										$sibling->given_names() . ',';
									$printed_sibling = 1;
									last;
								}
							}
						}
						# FIXME: only checks when there are @siblings
						if($bdiff->in_units('years') >= 30) {
							my $with_mother;
							if($mother) {
								my @mr = get_all_residences(person => $mother);
								foreach my $mr(@mr) {
									my $mdate = $mr->date();
									next if(!defined($mdate));
									next if($mdate ne $rdate);
									if(place({ person => $mother, record => $mr }) eq $place) {
										$with_mother++;
										last;
									}
								}
							}
							my $with_father;
							if($father) {
								my @fr = get_all_residences(person => $father);
								foreach my $fr(@fr) {
									my $fdate = $fr->date();
									next if(!defined($fdate));
									next if($fdate ne $rdate);
									if(place({ person => $father, record => $fr }) eq $place) {
										$with_father++;
										last;
									}
								}
							}
							if($with_mother || $with_father) {
								if($first) {
									$residencestring .= ($printed_sibling ? ' and ' : ' with ') .
										($person->pronoun() eq 'She' ? 'her' : 'his');
								} else {
									$residencestring =~ s/,$//;
									if($language eq 'French') {
										$residencestring .= ' et';
									} else {
										$residencestring .= ' and';
									}
								}
								$printed_sibling = 1;
								$first = 0;

								if($with_mother && $with_father) {
									$residencestring .= ' parents ';
								} elsif($with_mother) {
									$residencestring .= ' mother ' . $mother->given_names();
								} elsif($with_father) {
									$residencestring .= ' father ' . $father->given_names();
								}
							}
						}
						if($spouse && $marriage_dt && (my $rdate_dt = date_to_datetime($rdate))) {
							if($marriage_dt > $rdate_dt) {
								my @sr = get_all_residences(person => $spouse);
								foreach my $sr(@sr) {
									my $sdate = $sr->date();
									next if(!defined($sdate));
									next if($sdate ne $rdate);
									if(place({ person => $spouse, record => $sr }) eq $place) {
										if($language eq 'French') {
											$residencestring .= ($printed_sibling ? ' et ' : ' avec ') .
												($person->pronoun() eq 'She' ? 'son futur mari, ' : 'sa futue femme, ') .
												$spouse->given_names();
										} else {
											$residencestring .= ($printed_sibling ? ' and ' : ' with ') .
												($person->pronoun() eq 'She' ? 'her future husband, ' : 'his future wife, ') .
												$spouse->given_names();
										}
										last;
									}
								}
							}
						}
					}
				}
				if((!($opts{'c'} && $residence->source())) && (my $notes = notes({ record => $residence }))) {
					$notes =~ s/\.$//;
					$notes = lcfirst($notes);
					$residencestring .= " ($notes)";
				} elsif($opts{'c'}) {
					if($residencecitations{$residence}) {
						my $remove_comma = 0;
						if($residencestring =~ s/,$//) {
							$remove_comma = 1;
						}
						$residencestring .= '[' . $residencecitations{$residence} . ']';
						if($remove_comma) {
							$residencestring .= ',';
						}
					}
					if($residence->place() &&
					  (!$rdate) &&
					  ($count <= (scalar(@residencelist) - 1)) &&
					  ($residencecitations{$residence})) {
						my $peek = $residencelist[$count + 1];
						if($peek && places_are_the_same({ person => $person, first => $residence, second => $peek })) {
							if($residencecitations{$peek}) {
								$residencestring .= '[' . $residencecitations{$peek} . ']';
							}
						}
					}
				}
				$count++;
				if(($count == 1) && (scalar(@residencelist) == 2)) {
					if($print_year_only) {
						$residencestring .= $rdate;
						$print_year_only = 0;
					}
				} else {
					my $peek = $residencelist[$count];
					if($peek && places_are_the_same({ person => $person, first => $residence, second => $peek })) {
						$peek = $residencelist[$count + 1];
						if($peek && places_are_the_same({ person => $person, first => $residence, second => $peek })) {
							if((!$opts{'c'}) && $rdate && ($rdate =~ /^\d{4}$/) && $peek->date() && ($peek->date() =~ /^\d{4}$/)) {
								if((!$print_year_only) && !notes(record => $peek)) {
									$residencestring .= '-';
									$print_year_only = 1;
								}
							} elsif($print_year_only && $rdate) {
								$residencestring .= $rdate;
								$print_year_only = 0;
							}
						}
					} elsif($print_year_only) {
						$residencestring .= $rdate;
						$print_year_only = 0;
					}
				}
				if($residencestring) {
					$residencestring =~ s/^\s//;
					if($language eq 'French') {
						$residencestring =~ s/(.+), (his|her) /$1 et $2 /;
					} else {
						$residencestring =~ s/(.+), (his|her) /$1 and $2 /;
					}
					push @residencestringarray, $residencestring;
					$printed_residence = 1;
				}
			}

			# Print out the residence strings with semi-colons between each residence
			if(scalar(@residencestringarray)) {
				$bio .= '. ' unless($end_of_sentence);
				my $first = $residencelist[0];
				if((scalar(@residencelist) == 1) && (my $rdate = $first->date())) {
					$bio .= ' ' . ucfirst(year({ person => $person, date => $rdate, circa => 'About' }));
				} else {
					if($opts{'B'}) {
						if(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage)) {
							$text->textend();

							$pdfpage = PDFPage->new();

							$text = $pdfpage->text();
							$text->font($params{'font'}, 12);
							pdfprint(string => $bio, text => $text, pdfpage => $pdfpage);
						}
						$bio = ' ';
					} else {
						$bio .= "\n\t";
					}
					if($language eq 'French') {
						$bio .= 'Pendant sa vie';
					} else {
						$bio .= 'During ' . lc($person->possessive()) . ' life';
					}
				}

				# print Data::Dumper->new([\@residencestringarray])->Dump();
				if($language eq 'French') {
					$bio .= ', ' . lcfirst($pronoun) . ' habitait ';
				} else {
					$bio .= ', ' . lcfirst($pronoun) . ' was living ';
				}
				if($language eq 'French') {
					$bio .= Lingua::EN::Inflect::WORDLIST(@residencestringarray, {sep => '; ', conj => 'et'});
				} else {
					$bio .= Lingua::EN::Inflect::WORDLIST(@residencestringarray, {sep => '; '});
				}

				if($placeofdeath && !$aod) {
					my $lastresidence = $residencelist[scalar(@residencelist) - 1];
					my $deathplace = place({ person => $person, record => $death });
					my $lastdate = $lastresidence->date();
					$lastresidence = place({ person => $person, record => $lastresidence });
					if(defined($lastdate) && ($deathplace eq $lastresidence)) {
						my $p = lcfirst($pronoun);
						$bio .= " which is where $p died";
						if($dateofdeath) {
							my $date = year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt });
							$lastdate =~ s/^.*(\d{4})$/$1/;
							$date =~ /, (\d{3,4})$/;
							if($lastdate == $yod) {
								$date =~ s/, (\d{3,4})$//;
							}
							$bio .= " $date";
						}
						$bio .= "[$_]" foreach(List::Util::uniq(sort @deathcitations));
						# Print notes about the death, if any
						if(my $notes = notes({ person => $person, record => $death })) {
							$notes =~ tr/\r//;
							$notes =~ tr/\n/ /;
							$notes =~ s/\.$//;
							$notes = lcfirst($notes) unless($notes =~ /^[A-Z]{2}/);
							$bio .= " ($notes)";
						}
						$diedathome = 1;
					}
				}
				$bio .= '. ';
				$end_of_sentence = 1;
			}
		}
		$bio =~ s/,;/;/g;
		$bio =~ s/;$//;
		$bio =~ s/,.$/./;

		my $all_events_have_date = 1;
		foreach my $event(@events) {
			if((ref($event) ne 'Gedcom::Record') || !$event->date()) {
				$all_events_have_date = 0;
				last;
			}
			my $date = $event->date();
			if(($date !~ /^\d/) || ($date =~ /[a-z]$/i) ||
			   ($date =~ /[\/\-]/) || !date_parser_cached(date => $date)) {
				$all_events_have_date = 0;
				last;
			}
			if(!date_parser_cached(date => $date)) {
				complain({
					person => $person,
					warning => "Event has an invalid date of $date"
				});
				$all_events_have_date = 0;
				last;
			}
		}
		if($all_events_have_date) {
			@events = Sort::Key::DateTime::dtkeysort { $dfn->parse_datetime(@{$date_parser->parse(date => $_->date())}[0]->{'canonical'}) } @events;
		}
		if((scalar(@events) == 2) &&
		   (ref($events[0]) eq 'Gedcom::Record') &&
		   (ref($events[1]) eq 'Gedcom::Record') &&
		   ((($events[0]->type() eq 'Arrival') && ($events[1]->type() eq 'Departure')) ||
		    (($events[1]->type() eq 'Arrival') && ($events[0]->type() eq 'Departure')))) {
			# Simple case - one journey made
			$bio .= '.  ' if(!$end_of_sentence);

			my $arrival = ($events[0]->type() eq 'Arrival') ? $events[0] : $events[1];
			my $departure = ($events[0]->type() eq 'Departure') ? $events[0] : $events[1];
			$bio .= journey({ person => $person, arrival => $arrival, departure => $departure }) . '.  ';

			$end_of_sentence = 1;
		} elsif(scalar(@events) == 1) {
			$bio .= '. ' if(!$end_of_sentence);
			$end_of_sentence = 1;

			my $event = $person->event();
			if(!ref($event)) {
				my $e = $person->tag_record('EVEN');
				if(ref($e) eq 'Gedcom::Record') {
					$event = $e;
				} else {
					red_warning({ person => $person, warning => "Event record is just description ($event), infomation has been lost" });
					$bio .= ' ' . ucfirst($event) . '. ';
				}
			}
			if(ref($event) eq 'Gedcom::Record') {
				my $type = $event->type();
				if(!defined($type)) {
					red_warning({ person => $person, warning => "Can't determine type of event, or the event type is empty" });
				} elsif($type eq 'Arrival') {
					$bio .= ' ' . $person->pronoun() . ' arrived';
					if(my $p = place({ person => $person, record => $events[0] })) {
						$bio .= $p;
					} else {
						complain({ person => $person, warning => 'Arrival record has no place' });
					}
					if(my $y = year({ person => $person, record => $events[0] })) {
						$bio .= " $y";
					} else {
						complain({ person => $person, warning => 'Arrival record has no date' });
					}
					if(my $spouse = $spouses[0]) {
						foreach my $sevent($spouse->event()) {
							if(ref($sevent) eq 'Gedcom::Record') {
								my $type = $event->type();
								if(!defined($type)) {
									red_warning({ person => $spouse, warning => "Can't determine type of event, or the event type is empty" });
								} elsif($sevent->place() && ($type eq 'Arrival') &&
								   $event->date() && $sevent->date() &&
								   ($event->date() eq $sevent->date()) &&
								   ($event->place() eq $sevent->place())) {
									$bio .= ' with ' .
										lcfirst($person->possessive()) . ' ' .
										(($sex eq 'M') ? 'wife' : 'husband') .
										' ' . $spouse->given_names();
								}
							}
						}
					}
					if(my $notes = notes({ record => $event })) {
						$notes = lcfirst($notes);
						$notes =~ s/\.$//;
						$bio .= " ($notes)";
					}
					$bio .= '. ';
				} elsif($type eq 'Departure') {
					$bio .= ' ' . $person->pronoun();
					if($ENV{'LANG'} =~ /^en_US/) {
						$bio .= ' traveled';
					} else {
						$bio .= ' travelled';
					}
					my $place = place({ person => $person, record => $events[0] });
					$place =~ s/^\sin/ from/;
					$bio .= "$place " .
						year({ person => $person, record => $events[0] });
					if(my $notes = notes({ record => $event })) {
						$notes = lcfirst($notes);
						$bio .= " ($notes)";
					}
					$bio .= '. ';
				} elsif(($type eq 'Military service') || ($type eq 'Military')) {
					$bio .= '. ' if(!$end_of_sentence);
					my $date = year(record => $event);
					if($date && ($date !~ /^from /i)) {
						$bio .= ' ' . ucfirst($date) . ' ' . lcfirst($pronoun) . ' was serving in the military';
					} else {
						$bio .= " $pronoun was serving in the military";
					}
					if(my $place = place({ person => $person, record => $event })) {
						$bio .= $place;
					}
					if($date && ($date =~ /^from /i)) {
						$bio .= " $date";
					}

					if(my $notes = notes(record => $event)) {
						$notes = lcfirst($notes) unless($notes =~ /^(RAF|Royal Navy)/);
						$notes =~ s/[\s\.]+$//;
						$bio .= " ($notes)";
					}
					$end_of_sentence = 0;
				# } elsif(($type !~ /^Census U[KS] \d{4}$/) &&
				} elsif(($type !~ /Census/) &&
					($type ne 'Race') &&
					($type ne 'Custom Marriage') &&
					($type ne 'Register UK 1939')) {

					red_warning({ person => $person, warning => "Unhandled event type: $type" });
					if(my $notes = notes(record => $event)) {
						$notes = ucfirst($notes);
						$bio .= " ($notes)";
						$end_of_sentence = 0;
					}
				}
			}
		} else {
			my $mentioned_military;
			my $index = 0;
			my $previous;
			my $prev_type;
			foreach my $event(@events) {
				$index++;
				if(!ref($event)) {
					my $e = $person->tag_record('EVEN', $index);
					if(ref($e) eq 'Gedcom::Record') {
						$event = $e;
					} else {
						red_warning({ person => $person, warning => "Event record is just description ($event), infomation has been lost" });
						$bio .= ' ' . ucfirst($event) . '. ';
					}
				}
				if(ref($event) eq 'Gedcom::Record') {
					my $type = $event->type();
					if($type eq 'Military service') {
						if(!$mentioned_military) {
							$bio .= '. ' if(!$end_of_sentence);
							$bio .= " $pronoun served in the military";
							if(my $place = place({ person => $person, record => $event, allow_empty => 1 })) {
								$bio .= $place;
							}
							if(my $date = year(record => $event)) {
								$bio .= " $date";
							}
							$mentioned_military = 1;
						}

						if(my $notes = notes(record => $event)) {
							$notes = lcfirst($notes) unless($notes =~ /^(RAF|Royal Navy)/);
							$notes =~ s/[\s\.]+$//;
							$bio .= " ($notes)";
						}
						$end_of_sentence = 0;
					} elsif($type eq 'Arrival') {
						if(!defined($event->place())) {
							complain({ person => $person, warning => 'Arrival record without destination' });
							next;
						}
						if(my $e = $events[$index]) {
							if(ref($e) && ($e->type() eq 'Arrival') && $event->date() && $e->date()) {
								$previous = $event;
								$prev_type = 'Departure';
								# FIXME: not all locations will be noted or notes printed
								next;
							}
						}
						if($previous) {
							if($prev_type eq 'Departure') {
								$bio .= journey({ person => $person, arrival => $event, departure => $previous });
							} else {
								# Two arrival records, put into one sentence for improved readability
								my $date1 = year({ record => $previous });
								my $date2 = year({ record => $event });
								my $year1;
								my $year2;
								if($date1 =~ /(.*)\s?(\d{4})$/) {
									$date1 = $1;
									$year1 = $2;
									$date1 =~ s/,\s//;
								}
								if($date2 =~ /(.*)\s?(\d{4})$/) {
									$date2 = $1;
									$year2 = $2;
									$date2 =~ s/,\s//;
								}
								$bio .= '. ' if(!$end_of_sentence);
								$bio .= ' ';
								if(defined($year1) && defined($year2) && ($year1 == $year2)) {
									if($date1 eq 'in ') {
										$date1 = '';
									} else {
										$date1 = " $date1";
									}
									$bio .= "During $year1 " . lcfirst($pronoun) . ' arrived' .
										place({ person => $person, record => $previous }) .
										"$date1 and" .
										place({ person => $person, record => $event, nopreposition => 1 }) .
										" $date2. ";
								} else {
									$bio .= ucfirst(year({ person => $person, record => $previous })) .
										' ' . lcfirst($person->pronoun()) .
										' arrived' .
										place({ person => $person, record => $previous }) .
										' and ' .
										year({ person => $person, record => $event }) .
										' ' . lcfirst($pronoun) .
										' arrived' .
										place({ person => $person, record => $event });
								}
							}
							$previous = undef;
						} elsif(my $place = place({ person => $person, record => $event })) {
							if(my $year = year({ person => $person, record => $event })) {
								if($end_of_sentence) {
									$bio .= ' ' . ucfirst($year);
								} else {
									$bio .= $year;
								}
								if(my $notes = notes(record => $event)) {
									$notes = lcfirst($notes);
									$bio .= " ($notes)";
								}
								$bio .= ' ' . lcfirst($person->pronoun()) . " arrived$place";
							} else {
								complain({ person => $person, warning => "Can't determine $type date" });
							}
						} else {
							complain({ person => $person, warning => "Can't determine $type location" });
						}
						$bio .= '. ';
						$end_of_sentence = 1;
					} elsif($type eq 'Departure') {
						if(!defined($event->place())) {
							complain({ person => $person, warning => 'Departure record without destination' });
							next;
						}
						if($events[$index] && (ref($events[$index]) eq 'Gedcom::Record') && ($events[$index]->type() eq 'Arrival') && $event->date()) {
							if($events[$index]->date()) {
								$previous = $event;
								$prev_type = 'Departure';
								# FIXME: not all notes will be printed
								next;
							}
						}
						if($previous) {
							if($prev_type eq 'Arrival') {
								$bio .= journey({ person => $person, arrival => $previous, departure => $event });
							}
							$previous = undef;
						} else {
							$bio .= ' ' . $person->pronoun();
							if($ENV{'LANG'} =~ /^en_US/) {
								$bio .= ' traveled';
							} else {
								$bio .= ' travelled';
							}
							my $place = place({ person => $person, record => $event });
							$place =~ s/^\sin/ from/;
							if($event->date()) {
								$bio .= "$place " .
									year({ person => $person, record => $event });
							} else {
								$bio .= $place;
							}
							if(my $notes = notes(record => $event)) {
								$notes = lcfirst($notes);
								$bio .= " ($notes)";
							}
						}
						$bio .= '. ';
						$end_of_sentence = 1;
					} elsif($type eq 'Story') {
						if(my $notes = notes(record => $event)) {
							if(!$end_of_sentence) {
								$bio .= '. ';
							}
							$notes =~ s/\.$//;
							# TODO:  Do this if the notes doesn't include a date
							# if(my $date = year(record => $event)) {
								# $bio .= ' ' . ucfirst($notes) . " $date. ";
							# } else {
								$bio .= ' ' . ucfirst($notes) . '. ';
							# }
							$end_of_sentence = 1;
						}
					} elsif($type eq 'Court') {
						$bio .= '. ' if(!$end_of_sentence);
						$bio .= " $pronoun was in court";
						if(my $place = place({ person => $person, record => $event, allow_empty => 1 })) {
							$bio .= $place;
						}
						if(my $date = year(record => $event)) {
							$bio .= " $date";
						}
						if(my $notes = notes(record => $event)) {
							$notes = lcfirst($notes);
							$notes =~ s/\.$//;
							$bio .= " ($notes).";
							$end_of_sentence = 1;
						}
					# } elsif(($type !~ /^Census U[KS] \d{4}$/) &&
					} elsif(($type !~ /Census/) &&
						($type ne 'Register UK 1939') &&
						($type ne 'Race') &&
						($type ne 'Hospitalisation')) {
						red_warning({ person => $person, warning => "Unknown event type: $type" });
						if(my $notes = notes(record => $event)) {
							$notes =~ s/\.$//;
							my $date = year(record => $event);
							if($end_of_sentence) {
								if($date) {
									$bio .= ' ' . ucfirst($notes) . " $date. ";
								} else {
									$bio .= ' ' . ucfirst($notes) . '. ';
								}
							} else {
								$notes = lcfirst($notes);
								if($date) {
									$bio .= " ($date, $notes)";
								} else {
									$bio .= " ($notes)";
								}
							}
						}
					}
				}
			}
		}

		if(my $profile_object = $person->tag_record('_MILT')) {
			# $person->resolve_xref($profile_object->value());
			if(my $value = $profile_object->get_value()) {
				$bio .= '. ' if(!$end_of_sentence);
				$value =~ s/[\s\.]+$//;
				$bio .= " $pronoun served in the military ($value). ";
				$end_of_sentence = 1;
			}
		}

		if($placeofburial || $dateofburial || $placeofcremation || $dateofcremation) {
			if($aod || ((!$dateofdeath) && !$placeofdeath)) {
				$bio .= '. ' if(!$end_of_sentence);
				my $type = 'burial';
				if($placeofcremation || $dateofcremation) {
					$type = 'cremation';
				}
				if($dateofburial || $dateofcremation) {
					$bio .= ($type eq 'burial') ? " $pronoun was buried" : " $pronoun was cremated";
					if(my $city = ($placeofburial // $placeofcremation)) {
						if($placeofbirth && ($city eq $placeofbirth)) {
							if(my $address = $burial->address()) {
								$bio .= " at $address";
							}
							$bio .= ' in ' .
								lcfirst($person->possessive()) .
								' home town of ';
							if($city =~ /^(.+?),/) {
								$bio .= $1;
							} else {
								$bio .= place({
									person => $person,
									place => $city
								});
							}
						} else {
							my $opts = {
								person => $person,
								there => $placeofdeath,
								places_printed => \%places_printed,
								must_postdate => $birth_dt
							};
							if($type eq 'burial') {
								$opts->{'place'} = $placeofburial;
								if(my $address = $burial->address()) {
									$opts->{'address'} = $address;
								}
							} else {
								$opts->{'place'} = $placeofcremation;
								if(my $address = $cremation->address()) {
									$opts->{'address'} = $address;
								}
							}
							$bio .= place($opts);
						}
					}
					my $b;
					if($type eq 'burial') {
						$bio .= ' ' . year({ person => $person, date => $dateofburial });
						$b = notes({ record => $burial, paragraph => 0 });
					} else {
						$bio .= ' ' . year({ person => $person, date => $dateofcremation });
						$b = notes({ record => $cremation, paragraph => 0 });
					}
					if($b) {
						$b =~ s/\.$//;
						$b =~ tr/\r//;
						$bio .= " ($b)";
					}
				} elsif($placeofbirth && ($placeofburial eq $placeofbirth)) {
					$bio .= " $pronoun was buried";
					if(my $address = $burial->address()) {
						$bio .= " at $address";
					}
					$bio .= ' in ' . lcfirst($person->possessive()) .
						' home town of ';
					my $city = $placeofburial;
					if($city =~ /^(.+?),/) {
						$bio .= $1;
					} else {
						$bio .= place({ person => $person, place => $placeofburial });
					}
				} else {
					$bio .= " $pronoun " .
						(($language eq 'French') ? 'est enterré' :  'is buried') .
						place({ person => $person, record => $burial, places_printed => \%places_printed, there => $placeofmarriage });
				}
				$end_of_sentence = 0;
			} elsif($dateofdeath || $placeofdeath) {
				$bio .= '.' if(!$end_of_sentence);
				if($opts{'B'}) {
					if($bio) {
						if(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage)) {
							$text->textend();

							$pdfpage = PDFPage->new();

							$text = $pdfpage->text();
							$text->font($params{'font'}, 12);
							pdfprint(string => $bio, text => $text, pdfpage => $pdfpage);
						}
						$bio = ' ';
					}
				} else {
					$bio .= "\n\t";
				}
				if(!$diedathome) {
					if($language eq 'French') {
						if($sex eq 'M') {
							$bio .= "$pronoun est mort";
						} else {
							$bio .= "$pronoun est morte";
						}
					} else {
						$bio .= "$pronoun died";
					}
					if($dateofdeath) {
						my $y = year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt });
						if($y =~ /^fro?m (.+) to (.+)/i) {
							$y = "between $1 and $2";
						}
						$bio .= " $y";
					}
					if($placeofdeath && (my $p = place({ person => $person, record => $death, places_printed => \%places_printed }))) {
						$bio .= $p;
						$places_printed{$p} = 1;
					}
					$bio .= "[$_]" foreach(List::Util::uniq(sort @deathcitations));
					# Print notes about the death, if any
					if(my $notes = notes({ person => $person, record => $death })) {
						$notes =~ tr/\r//;
						$notes =~ tr/\n/ /;
						$notes =~ s/\.$//;
						$notes = lcfirst($notes) unless($notes =~ /^[A-Z]{2}/);
						$bio .= " ($notes)";
					}
				}
				my $opts = {
					person => $person,
					place => $placeofburial // $placeofcremation,
					there => $placeofdeath,
					places_printed => \%places_printed,
					must_postdate => $birth_dt,
				};
				my $address;
				if($address = get_value({ person => $person, value => 'burial address' })) {
					$opts->{'address'} = $address;
				}
				if($dateofburial) {
					if($diedathome) {
						$bio .= "$pronoun was buried";
					} else {
						$bio .= ' and was buried';
					}
					if($placeofburial) {
						if(defined($placeofdeath) && ($placeofburial eq $placeofdeath) && !$death->address()) {
							$bio .= ' there';
							if($address) {
								$bio .= " at $address";
							}
						} else {
							$bio .= place($opts);
						}
					}
					my $must_postdate;
					if($death_dt) {
						$must_postdate = $death_dt;
					} elsif(!defined($dateofdeath)) {
						complain({
							person => $person,
							warning => 'Date of burial is known but not of death, suggest adding "Abt. YEAR"'
						});
					} elsif($dateofdeath =~ /^(Abt|ca?)\.?\s*(.+)/i) {
						my $d = $2;
						if($d !~ /^\d/) {
							$must_postdate = date_to_datetime("1 $d");
						} else {
							$must_postdate = date_to_datetime($d);
						}
					}
					$bio .= ' ' . year({ person => $person, date => $dateofburial, must_postdate => $must_postdate });
				} elsif($placeofdeath && $placeofburial && ($placeofburial eq $placeofdeath) &&
				   $burial->address() && !$death->address()) {
					$bio .= (($language eq 'French') ? ' et est y enterré à' : ' and is buried there at ') . $burial->address();
				} elsif(my $b = place($opts)) {
					if($diedathome) {
						$bio .= "$pronoun ";
						$bio .= (($language eq 'French') ? ' est enterré' :  ' is buried') .
							$b;
					} else {
						$bio .= (($language eq 'French') ? ' et est enterré' :  ' and is buried') .
							$b;
					}
				}
				if(my $b = notes({ record => ($burial // $cremation), paragraph => 0 })) {
					$b =~ s/\.$//;
					$b =~ tr/\r//;
					$bio .= " ($b)";
				}
				$end_of_sentence = 0;
			}
			$bio .= "[$_]" foreach(sort @burialcitations);
		} elsif((!$aod) && ($placeofdeath || $dateofdeath) && !$diedathome) {
			# TODO - extract marriage banns information
			# if($person->marriage_bann()) {
				# die 'foo';
			# }
			if($placeofdeath && (scalar(@spouses) <= 1) && $placeofmarriage && ($placeofdeath eq $placeofmarriage) && !$printed_residence) {
				if($language eq 'French') {
					if($end_of_sentence) {
						$bio .= " C'est";
					} else {
						$bio .= ', qui est';
					}
					$bio .= ' aussi où ' . lcfirst($pronoun);
				} else {
					if($end_of_sentence) {
						$bio .= ' That';
					} else {
						$bio .= ', which';
					}
					$bio .= ' is also where ' . lcfirst($pronoun);
				}
			} elsif($aob && scalar(@spouses) && ($numberofchildren == 0)) {
				if($end_of_sentence) {
					$bio .= " $pronoun";
				} elsif($language eq 'French') {
					$bio .= ' et';
				} else {
					$bio .= ' and';
				}
			} else {
				$bio .= '.' if(!$end_of_sentence);
				if($opts{'B'}) {
					if($bio) {
						if(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage)) {
							$text->textend();

							$pdfpage = PDFPage->new();

							$text = $pdfpage->text();
							$text->font($params{'font'}, 12);
							pdfprint(string => $bio, text => $text, pdfpage => $pdfpage);
						}
						$bio = ' ';
					}
				} else {
					$bio .= "\n\t";
				}
				$bio .= $pronoun;
			}
			if($language eq 'French') {
				if($sex eq 'M') {
					$bio .= ' est mort';
				} else {
					$bio .= ' est morte';
				}
			} else {
				$bio .= ' died';
			}
			if($dateofdeath) {
				if($dateofbirth && ($dateofdeath eq $dateofbirth)) {
					$bio .= ' on the same day';
				} elsif($placeofdeath && $placeofmarriage && ($placeofdeath eq $placeofmarriage) && !$printed_residence) {
					my $y = year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt });
					if($y =~ /^fro?m (.+) to (.+)/i) {
						$y = "between $1 and $2";
					}
				} elsif($placeofbirth && $placeofdeath && ($placeofdeath eq $placeofbirth) && (scalar(@spouses) <= 1) && ($placeofdeath =~ /^(.+?),.*/) && !$printed_residence) {
					$bio .= " in $1 " .
						year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt });
				} else {
					my $y = year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt });
					if($y =~ /^fro?m (.+) to (.+)/i) {
						$y = "between $1 and $2";
					}
					$bio .= " $y";
					if($placeofdeath && ((!$placeofmarriage) || ($placeofdeath ne $placeofmarriage) || $printed_residence)) {
						my $place = place({ person => $person, record => $death, places_printed => \%places_printed });
						if(!defined($place)) {
							$place = place({ person => $person, place => $placeofdeath, places_printed => \%places_printed });
						}
						if(defined($place)) {
							$bio .= $place;
						} else {
							complain({
								person => $person,
								warning => "Place of death ($placeofdeath) can't be parsed"
							});
						}
					}
				}
			} elsif((!$placeofmarriage) || ($placeofdeath ne $placeofmarriage)) {
				$bio .= place({ person => $person, place => $placeofdeath });
			}
			$bio .= "[$_]" foreach(List::Util::uniq(sort @deathcitations));
			# Print notes about the death, if any
			if(defined($death) && (my $notes = notes({ person => $person, record => $death, paragraph => 0 }))) {
				$notes =~ tr/\r//;
				$notes =~ s/\.$//;
				# FIXME: If the notes are so long they go over
				#	a page split into more than one page
				#	poperly rather than don't print, as now
				if((!$opts{'B'}) || (length($notes) < 4000)) {
					$bio .= " ($notes)";
				}
			}
			if($bio =~ /\.$/) {
				$end_of_sentence = 1;
			} else {
				$end_of_sentence = 0;
			}
		}

		$bio .= '.' if(!$end_of_sentence);

		# if($death && (my $notes = notes({ person => $person, record => $death, paragraph => 1 }))) {
			# print "\n$notes";
		# }

		if(my $notes = notes({ person => $person, record => $person, paragraph => 1 })) {
			if($opts{'B'}) {
				if($bio) {
					if(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage)) {
						$text->textend();

						$pdfpage = PDFPage->new();

						$text = $pdfpage->text();
						$text->font($params{'font'}, 12);
						# print STDERR "\n", length($bio), "\n", length($notes), "\n";
						die "$bio: Print failure" if(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage));
					}
					$bio = ' ';
				}
			} else {
				$bio .= "\n";
			}
			$bio .= $notes;
		}

		if($opts{'C'}) {
			foreach my $child(@children) {
				if(my $dob = dateofbirth($child)) {
					unless($opts{'B'}) {
						$bio .= "\n\t";
					}
					$bio .= $child->given_names() .
						' was born ' .
						year({ person => $child, date => $dob });
					if($opts{'w'} && ($birth_dt || $death_dt) &&
					   ($dob !~ /^\d{3,4}$/) && ($dob =~ /^\d/) &&
					   ($dob !~ /[a-z]$/i)) {
						my $d;
						eval {
							$d = $date_parser->parse(date => $dob);
						};
						if($d) {
							$d = @{$d}[0];
						}
						if($d) {
							$d = $dfn->parse_datetime($d->{'canonical'});
							if($birth_dt && ($d <= $birth_dt)) {
								complain({ person => $child, warning => 'born before parent was born' });
							}
							if(($sex eq 'F') && $death_dt && ($d > $death_dt)) {
								complain({ person => $child, warning => 'born after mother died' });
							} elsif(($sex eq 'M') && $death_dt && ($d > ($death_dt + $tenmonths))) {
								# Allow the child to be
								# born up to 10 months
								# after the death of the
								# father
								complain({ person => $child, warning => 'born more than 10 months after father died' });
							}
						}
					}
					$bio .= '.';
				} elsif(get_value({ person => $child, value => 'baptism date' })) {
					$bio .= "\t" . $child->given_names() .
						' was born c. ' .
						get_value({ person => $child, value => 'baptism date' }) .
						'.';
				}
			}

			$bio .= "\n" if(scalar(@children));
		}

		if($opts{'c'}) {
			my $ufinder = URI::Find::Schemeless->new(sub {
				my($uri, $orig_uri) = @_;

				if($opts{'w'}) {
					my $u = URI->new($orig_uri);
					if($u && (ref($u) ne 'URI::_generic') && !$browser->head($orig_uri)) {
						complain({ person => $person, warning => "$orig_uri: not found" });
					}
				}
				return $orig_uri;
			});

			my %census_years;
			my $burialrecord;
			foreach my $citation(1..$citationcount) {
				if(!$citations{$citation}) {
					complain({
						person => $person,
						warning => "[$citation]: empty citation"
					});
					next;
				}
				my $title = $citations{$citation}->title();
				if(!defined($title)) {
					$title = notes(record => $citations{$citation});
					if(!defined($title)) {
						complain({
							person => $person,
							warning => "[$citation]: no citation title"
						});
						$title = 'No citation title';
					}
				}
				if($opts{'B'}) {
					if($bio) {
						if(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage)) {
							$text->textend();

							$pdfpage = PDFPage->new();

							$text = $pdfpage->text();
							$text->font($params{'font'}, 12);
							pdfprint(string => $bio, text => $text, pdfpage => $pdfpage);
						}
						$bio = undef;
					}
				} else {
					$bio =~ s/\s+$//;
					$bio .= "\n\t";
				}
				$bio .= "[$citation]: $title";
				# if(defined(my $publication = $citations{$citation}->publication())) {
					# print " $publication";
					# if(defined(my $continuation = $citations{$citation}->cont())) {
						# print $continuation;
					# }
				# }
				if(defined(my $page = $citations{$citation}->page())) {
					$bio .= " $page";
				}

				my @notes = $citations{$citation}->note();
				foreach my $note(@notes) {
					if(ref($note) eq 'Gedcom::Record') {
						$note = $note->note();
					}

					if($note && ($note !~ /^This information comes from/)) {
						if($opts{'w'}) {
							$ufinder->find(\$note);
						}
						$bio .= " ($note)" unless($note eq $title);
					}
				}
				if($citationnotes{$citation}) {
					$citationnotes{$citation} =~ s/\.$//;
					$bio .= " ($citationnotes{$citation})";
				}

				if(($title =~ /census/i) && ($title =~ /(\d{3,4})/)) {
					$census_years{$1} = $title;
				}
				if(($title =~ /find a grave/i) ||
				   ($title =~ /billiongraves/i)) {
					$burialrecord = 1;
				}
			}
			$bio .= "\n" if($citationcount);

			if($opts{'w'}) {
				# People alive during the years when censues have been available must
				# have appeared in at least one census
				# FIXME:  should be a better test, e.g. catch people 1861-1930, don't
				#	catch 1862-1865.  The current test misses some but should have
				#	no false positives
				if((defined($yob) && ($yob >= 1841)) &&
				  ((defined($yod)) && ($yod <= 1911)) &&
				  (($yod - $yob) >= 10) &&
				  (scalar(keys(%census_years)) == 0)) {
					complain({ person => $person, warning => 'Appears in no censuses' });
				}

				my %unused_censuses = %census_years;
				foreach my $residence(@residences) {
					if(my $rdate = $residence->date()) {
						if($rdate =~ /(\d{3,4})$/) {
							$rdate = $1;
							delete $unused_censuses{$1};
						}
					}
				}
				foreach my $year(sort keys %unused_censuses) {
					complain({
						person => $person,
						warning => "The census for year $year has been citied, but its information has not been used as a residence"
					});
				}
				foreach my $event(@events) {
					if(ref($event) eq 'Gedcom::Record') {
						my $type = $event->type();
						my $year;
						if($type =~ /^Census U[KS] (\d{4})$/) {
							$year = $1;
							if(!$event->date()) {
								complain({ person => $person, warning => "Census for $year missing a date" });
							}
						} elsif($type eq 'Register UK 1939') {
							if(!$event->date()) {
								complain({ person => $person, warning => '1939 UK register is missing the date 29 Sep 1939' });
							}
							$year = 1939;
						} elsif($type =~ /^(\d{4}) Census of Canada/) {
							$year = $1;
							if(!$event->date()) {
								complain({ person => $person, warning => "Census for $year missing a date" });
							}
							# Check Location includes Canada
							if(my $place = place({ person => $person, record => $event, nopreposition => 1 })) {
								if($place =~ /Canada$/i) {
									complain({ person => $person, warning => "Canadian census for $year doesn't list Canada as the location" });
								}
							} else {
								complain({ person => $person, warning => "Canadian census for $year doesn't list Canada as the location" });
							}
						} elsif($type eq 'Census') {
							if(my $date = $event->date()) {
								if($date =~ /(\d{4})$/) {
									$year = $1;
								}
							}
							if(!defined($year)) {
								complain({ person => $person, warning => '1939 UK register is missing the date 29 Sep 1939' });
							}
						} else {
							next;
						}
						$census_years{$year} = $type;
						if(defined($yod) && ($year > $yod)) {
							complain({ person => $person, warning => "Census for $year after year of death ($yod)" });
						} elsif(defined($yob) && ($year < $yob)) {
							complain({ person => $person, warning => "Census for $year before year of birth ($yob)" });
						}
					}
				}
				foreach my $year(sort { $a <=> $b } keys(%census_years)) {
					if($census_years{$year + 20} && !$census_years{$year + 10}) {
						complain({
							person => $person,
							warning => 'Census information missing between ' . $census_years{$year} . ' and ' . $census_years{$year + 20}
						});
					}
				}
				if($dateofdeath && !defined($placeofdeath)) {
					complain({ person => $person, warning => 'Date of death is known, but not place' });
				} elsif($placeofbirth && $dateofdeath && (!$census_years{1939}) &&
				   (datecmp($dateofdeath, '1939') >= 0) && ($placeofbirth =~ /England$/) && ($placeofdeath =~ /England$/) &&
				   ((!$dateofbirth) || (datecmp($dateofbirth, '1939') <= 0))) {
					my $has1939 = 0;
					foreach my $residence(@residences) {
						if($residence->date() && ($residence->date() =~ /1939$/)) {
							$has1939 = 1;
							last;
						}
					}
					if(!$has1939) {
						complain({
							person => $person,
							warning => '1939 UK register information missing'
						});
					}
				}
				my $surname = $lastname;
				if(defined($sex) && ($sex eq 'F')) {
					if(my $husband = $person->husband()) {
						$surname = $husband->surname();
					}
				}
				if($yod && $firstname && $surname && !$burialrecord) {
					my %opts = (
						date_of_death => $yod,
						firstname => $firstname,
						lastname => $surname,
						ua => $browser,
					);
					if($placeofburial) {
						if($placeofburial =~ /.+,\s+(\w+)/) {
							$opts{'country'} = $1;
						}
					} elsif($placeofdeath) {
						if($placeofdeath =~ /.+,\s+(\w+)/) {
							$opts{'country'} = $1;
						}
					}
					if($opts{'country'} && ($opts{'country'} eq 'USA')) {
						$opts{'country'} = 'United States of America';
					}
					# foreach my $b(WWW::Scrape::FindaGrave->new(\%opts)) {
					if(defined($grave_modules)) {
						if(ref($grave_modules)) {
							foreach my $m(@{$grave_modules}) {
								my $b = $m->new(\%opts);
								while(my $url = $b->get_next_entry()) {
									complain({
										person => $person,
										warning => "possible burial link $url"
									});
								}
							}
						} else {
							my $b = $grave_modules->new(\%opts);
							while(my $url = $b->get_next_entry()) {
								complain({
									person => $person,
									warning => "possible burial link $url"
								});
							}
						}
					}
				}
			}
		}
		if($opts{'B'}) {
			if($bio) {
				$bio =~ s/\.\././g;
				if(length($bio) > 4000) {
					# It's not going to fit on one page
					# Split into paragraphs
					my @paras = split(/\n/, $bio);
					foreach my $p(@paras) {
						next if(length($p) == 0);
						if(length($p) > 4000) {
							# Very long paragraph
							my @lines = split(/\n/, wrap('', '', ($p)));
							foreach my $l(@lines) {
								if(!pdfprint(string => $l, text => $text, pdfpage => $pdfpage, noindent => 1)) {
									$text->textend();

									$pdfpage = PDFPage->new();

									$text = $pdfpage->text();
									$text->font($params{'font'}, 12);
									die "Print failure: $l" if(!pdfprint(string => $l, text => $text, pdfpage => $pdfpage, noindent => 1));
								}
							}
						} elsif(!pdfprint(string => $p, text => $text, pdfpage => $pdfpage)) {
							$text->textend();

							$pdfpage = PDFPage->new();

							$text = $pdfpage->text();
							$text->font($params{'font'}, 12);
							die "Print failure: $p" if(!pdfprint(string => $p, text => $text, pdfpage => $pdfpage));
						}
					}
				} elsif(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage)) {
					$text->textend();

					$pdfpage = PDFPage->new();

					$text = $pdfpage->text();
					$text->font($params{'font'}, 12);
					die 'Print failure' if(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage));
				}
				$bio = undef;
			}
		} else {
			if($bio eq "\t.") {
				complain({ person => $person, warning => "couldn't extract a biography" });
			}
			if($language eq 'English') {
				utf8::decode($bio);
			}
			print "$bio\n", '-' x 80, "\n";
		}
	} else {
		my ($dob, $dod);
		eval {
			$dob = dateofbirth($person);
			$dod = dateofdeath($person);
		};
		if($@) {
			warn "Can't parse record for $firstname $lastname";
			return;
		}

		if(defined($dob) && (!$onlydeaths) && !$onlybirthdays) {
			my $d;
			if(($dob !~ /^\d{3,4}$/) && ($dob =~ /^\d/)) {
				eval {
					$d = $date_parser->parse(date => $dob);
				};
			}
			if($d) {
				$d = @{$d}[0];
				$birth_dt = $dfn->parse_datetime($d->{'canonical'});
				print "\tBorn: ", $birth_dt->strftime('%x');
			} else {
				if($@) {
					if($opts{'f'}) {
						die $@;
					}
					if($opts{'w'}) {
						red_warning({ person => $person, warning => $@ });
					}
				}
				print "\tBorn: $dob";
			}
			print "\n";
		}
		if(defined($dod) && (!$onlydeaths) && !$onlybirthdays) {
			my $d;
			if(($dod !~ /^\d{3,4}$/) && ($dod =~ /^\d/)) {
				eval {
					$d = $date_parser->parse(date => $dod);
				};
			}
			if($d) {
				$d = @{$d}[0];
				$death_dt = $dfn->parse_datetime($d->{'canonical'});
				print "\tDied: ", $death_dt->strftime('%x');
			} else {
				if($@) {
					if($opts{'f'}) {
						die $@;
					}
					if($opts{'w'}) {
						red_warning({ person => $person, warning => $@ });
					}
				}
				print "\tDied: $dod\n";
			}
			print "\n";
		}
	}
	# $printed{$person->xref()} = 1;

	if($opts{'B'}) {
		my @images;
		my %files;
		foreach my $o($person->obje()) {
			my $obje;
			if(ref($o) eq 'Gedcom::Record') {
				$obje = $o;	# e.g. Ancestry
			} else {
				$obje = $ged->resolve_xref($o);	# e.g. FMP
			}
			next if(!defined($obje));
			if(my $file = $obje->file()) {
				if(ref($file) eq 'Gedcom::Record') {
					# warn $file->tag(), "\n" if($file->tag());
					$file = $file->{'file'};
					next if($file eq '*');
				}
				if($files{$file}) {
					print "$file is already printed\n" if($opts{'v'});
					next;
				}
				$files{$file} = 1;
				my $title = $obje->title() || $obje->tag_record('TITL', 1);
				my $form = $obje->form();
				if((!$form) && $obje->items()) {
					# Family Tree Maker does this
					my @items = $obje->items();
					$file = $items[0]->{'value'};
					# TODO: Find the title
				}
				$file =~ s/\{0\}//g;
				$file =~ s/\r//g;
				my $image;
				my $filename;
				my $orig_image;
				my $orig_filename;
				my $gd;
				if($file =~ /^http:\/\/(\w+)\.findmypast\.(co[\w\.]+)\/(.+)/) {
					$file = "https://$1.findmypast.$2/$3";
				}
				if(($file =~ /^https?:\/\//) && ($file !~ /\.jpe?g$/) && ($file !~ /ancestry.com.*image.*guid=/)) {
					$file =~ s/%2f/\//gi;

					my $resp = $cached_browser->get($file);
					if($resp->is_success() && ($resp->content_type() eq 'image/jpeg')) {
						$title = $file if(!defined($title));
						my $tmp = File::Temp->new(UNLINK => 0);
						$filename = $tmp->filename();
						open(my $fh, '>', $filename);
						print $fh $resp->decoded_content();
						close $fh;
						$orig_filename = $filename;
						my $resize = Image::Resize->new($filename);
						my $width = $resize->width();
						my $height = $resize->height();
						if($height > 250) {
							my $newwidth = $width * (250 / $height);
							my $newheight;
							if($newwidth > 550) {
								$newheight = $height * (550 / $width);
								$gd = $resize->resize(550, $newheight);
							} else {
								$gd = $resize->resize($newwidth, 250);
								$newheight = 205;
							}
						} elsif($width > 550) {
							my $newheight = $height * (550 / $width);
							$gd = $resize->resize(550, $newheight);
						}
						if($gd) {
							$image = $pdf->image_gd($gd, -lossless => 1);
						} else {
							$image = $pdf->image_jpeg($filename);
						}
						$orig_image = $pdf->image_jpeg($orig_filename);
					} else {
						if(!$resp->is_success()) {
							complain({ person => $person, warning => "download $file failed " . $resp->status_line() });
						}
						$title = undef;
					}
				} elsif(($file =~ /^([A-Z]:[\/\\].+\.jpe?g+)/) || ($file =~ /^(\/.+\.jpe?g)/)) {
					$form = 'JPG';
				}
				if((!defined($image)) && $form && (lc($form) eq 'jpg')) {
					if($file =~ /ancestry.com.+guid=.+&tid=/) {
						# Ancestry's Gedcoms are broken, perhaps pointing to an old
						# location that they forgot to fix
						if($file =~ /guid=([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})/) {
							# FIXME: Ancestry pictures attached from another
							# tree aren't downloaded.  This URL will generate a
							# 404
							$file = "https://mediasvc.ancestry.com/v2/image/namespaces/1093/media/$1.jpg?client=Trees";
						} else {
							complain({ person => $person, warning => "BUG: update ACOM mapping for $file" });
							unlink $filename if(defined($filename));
							unlink $orig_filename if(defined($orig_filename));
							next;
						}
					}
					my $rc;
					my $tmp = File::Temp->new(UNLINK => 0);
					$filename = $tmp->filename();
					$orig_filename = $filename;
					if(is_success($rc = getstore($file, $filename))) {
						my $resize = Image::Resize->new($filename);
						my $width = $resize->width();
						my $height = $resize->height();
						if($height > 250) {
							my $newwidth = $width * (250 / $height);
							my $newheight;
							if($newwidth > 550) {
								$newheight = $height * (550 / $width);
								$gd = $resize->resize(550, $newheight);
							} else {
								$gd = $resize->resize($newwidth, 250);
								$newheight = 250;
							}
						} elsif($width > 550) {
							my $newheight = $height * (550 / $width);
							$gd = $resize->resize(550, $newheight);
						}
						if($gd) {
							# $orig_image = $pdf->image_jpeg($orig_filename);
							# $tmp = File::Temp->new(UNLINK => 0);
							# $filename = $tmp->filename();
							# open(my $fh, '>', $filename);
							# print $fh $gd->jpeg();
							# close $fh;
							$image = $pdf->image_gd($gd, -lossless => 1);
						}
						$image = $pdf->image_jpeg($filename);
						$title = $file if(!defined($title));
						# $image->height(32);
						# $image->width(32);
					} else {
						red_warning({ person => $person, warning => "download $file failed to $filename: $rc" });
						$title = undef;
					}
				}
				if($title) {
					push @images, { image => $image, orig_image => $orig_image, title => $title, orig_filename => $orig_filename };
				}
				push @tmpfiles, $filename if(defined($filename));
				push @tmpfiles, $orig_filename if(defined($orig_filename) && ($orig_filename ne $filename));
			}
		}
		if(scalar(@images)) {
			$text->textend();
		}
		while(my $i = shift @images) {
			my $title = $i->{'title'};

			my $newpage;
			my $trigger_page_throw;
			if(my $image = $i->{'image'}) {
				if($opts{'v'}) {
					print "$title: height/width: ", $image->height(), '/', $image->width(), "\n";
				}

				if(($image->height() >= ($pdfpage->y() - 80)) ||
				   ($pdfpage->linesleft() <= 15)) {
					print "New page to fit image on it\n" if($opts{'v'});
					$pdfpage = PDFPage->new();
					$newpage = 1;
				}
				my $y = $pdfpage->newline() - $image->height();

				if(my $peek = $images[0]) {
					if(my $pimage = $peek->{'image'}) {
						if(($image->width() < 250) && ($pimage->width() < 250) &&
						   ($pimage->height() <= $y) && ($pimage->height() <= $image->height())) {
							# Print two images side by side
							$peek = shift @images;

							my $x = 150 - ($image->width() / 2);
							$pdfpage->page()->gfx()->image($image, $x, $y);
							$x = 450 - ($pimage->width() / 2);
							$pdfpage->page()->gfx()->image($pimage, $x, $y);
							$pdfpage->y($y);

							$text = $pdfpage->text();
							# This is needed because of the text end above
							$text->textstart() if(!$newpage);
							$text->font($pdf->corefont('Times-Italic'), 12);
							$x = 150 - (length($title) / 2);
							if(!pdfprint(string => $title, text => $text, pdfpage => $pdfpage, x => $x, centre => 1)) {
								die "Didn't make enough room for $title; y = ", $pdfpage->y();
							}
							my $ptitle = $peek->{'title'};
							$pdfpage->y($y);	# Put the two captions on the same line
							$x = 450 - (length($ptitle) / 2);
							if(!pdfprint(string => $ptitle, text => $text, pdfpage => $pdfpage, x => $x, centre => 1)) {
								die "Didn't make enough room for $ptitle ; y = ", $pdfpage->y();
							}
							# $text->textend();
							next;
						}
					}
				}

				my $orig_image = $i->{'orig_image'};

				next unless($image || $orig_image);

				if($orig_image && ($pdfpage->y() > ($orig_image->height() + 80)) && ($orig_image->width() < 550)) {
					# No need to shrink the image
					$y = $pdfpage->y() - $orig_image->height();
					my $x = 300 - ($orig_image->width() / 2);
					$pdfpage->page()->gfx()->image($orig_image, $x, $y);
					$pdfpage->y($y);
				} elsif($orig_image && $newpage && ($orig_image->width() < 550)) {
					# Shrink the image to take the entire page height and appropriate width
					my $width = $orig_image->width();
					my $height = $orig_image->height();
					if($height >= 650) {
						my $newwidth = ($width * 650) / $height;
						my $gd = GD::Image->new($i->{'orig_filename'});
						my $resize = Image::Resize->new($gd);
						$gd = $resize->resize($newwidth, 650);
						$image = $pdf->image_gd($gd, -lossless => 1);
						$width = $newwidth;
						$height = 650;
					} else {
						$image = $orig_image;
					}
					my $x = 300 - ($width / 2);
					$pdfpage->page()->gfx()->image($image, $x, 740 - $height);
					$pdfpage->y(740 - $height);
				} elsif($orig_image && $newpage && ($orig_image->height() < 650)) {
					# Shrink the image to take the entire page width and appropriate height
					my $width = $orig_image->width();
					my $height = $orig_image->height();
					if($width >= 500) {
						my $newheight = ($height * 500) / $width;
						my $gd = GD::Image->new($i->{'orig_filename'});
						my $resize = Image::Resize->new($gd);
						$gd = $resize->resize(500, $newheight);
						$image = $pdf->image_gd($gd, -lossless => 1);
						$width = 500;
						$height = $newheight;
					} else {
						$image = $orig_image;
					}
					my $x = 300 - ($width / 2);
					$pdfpage->page()->gfx()->image($image, $x, 740 - $height);
					$pdfpage->y(740 - $height);
				} elsif($orig_image && $newpage) {
					if($opts{'v'}) {
						print "$title height and width are too big. height/width: ", $orig_image->height(), '/', $orig_image->width(), "\n";
					}
					# Handle when both height and width are too big
					my $width = $orig_image->width();
					my $height = $orig_image->height();
					my $newwidth = ($width * 650) / $height;
					my $newheight = 650;
					if($newwidth > 500) {
						$newheight = ($height * 500) / $width;
						$newwidth = 500;
					}
					my $gd = GD::Image->new($i->{'orig_filename'});
					my $resize = Image::Resize->new($gd);
					$gd = $resize->resize($newwidth, $newheight);
					$image = $pdf->image_gd($gd, -lossless => 1);
					$height = $newheight;
					$width = $newwidth;
					my $x = 300 - ($width / 2);
					$pdfpage->page()->gfx()->image($image, $x, 740 - $height);
					$pdfpage->y(740 - $height);
					$trigger_page_throw = 1;
				} else {
					# Shrink the image to fit on the page
					if($image->height() > 650) {
						my $width = $image->width();
						my $height = $image->height();
						my $newwidth = ($width * 650) / $height;
						my $newheight = 650;
						if($newwidth > 500) {
							$newheight = ($height * 500) / $width;
							$newwidth = 500;
						}
						my $gd = GD::Image->new($i->{'orig_filename'});
						my $resize = Image::Resize->new($gd);
						$gd = $resize->resize($newwidth, $newheight);
						$image = $pdf->image_gd($gd, -lossless => 1);
						$height = $newheight;
						$width = $newwidth;
						$y = $pdfpage->newline() - $newheight;
					}
					my $x = 300 - ($image->width() / 2);
					$pdfpage->page()->gfx()->image($image, $x, $y);
					if($image->height() >= ($y - 80)) {
						print "It took the entire page\n" if($opts{'v'});
					}
					$pdfpage->y($y);
				}
			}

			if($title) {
				$text = $pdfpage->text();
				# This is needed because of the text end above
				$text->textstart() if(!$newpage);
				$text->font($pdf->corefont('Times-Italic'), 12);
				if(length($title) > 200) {
					complain({ person => $person, warning => "Truncating long picture title $title" });
					$title = substr $title, 0, 200;
				}
				my $x = 300 - (length($title) / 2);
				if(!pdfprint(string => $title, pdfpage => $pdfpage, x => $x, centre => 1)) {
					die "Didn't make enough room for '$title'; y = ", $pdfpage->y();
				}
				# $text->textend();
			}
			if($trigger_page_throw) {
				$pdfpage = PDFPage->new();
			}
		}
	}
	print Data::Dumper->new([$person->state()])->Dump() if($opts{'v'});
}

sub Gedcom::Individual::as_string
{
	my $self = shift;
	my %args = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $name;

	if($args{'use_aka'}) {
		my $n2 = $self->tag_record('NAME', 2);
		if(defined($n2) && (ref($n2) eq 'Gedcom::Record') && defined($n2->type()) && ($n2->type() eq 'AlsoKnownAs') && ($n2->value() ne $self->name())) {
			$name = $n2->value();
		} else {
			return;
		}
	} else {
		$name = $self->name();
	}

	$name =~ s/\///g;

	# FIXME: Correctly handle other names, relies on Lingua::EN::NameParse
	#	too much

	$name = Unicode::Diacritic::Strip::strip_diacritics($name);
	# $name =~ tr/čáň/can/;
	# $name =~ s/č/c/g;
	# $name =~ s/á/a/g;
	# $name =~ s/ň/n/g;
	$nameparser->parse($name);

	my %name_components = $nameparser->components();
	my $first_name = $name_components{'given_name_1'} // $name_components{'initials_1'};
	my $middle_name = $name_components{'middle_name'};
	my $surname = $name_components{'surname_1'};
	if($name_components{'surname_2'}) {
		$surname .= ' ' . $name_components{'surname_2'};
	}
	if($name_components{'non_matching'}) {
		if($name =~ /(\w{2,})\s(\w{2,})\s(\w+)\s(\w{2,})/) {
			# Name parser doesn't parse names like this very well
			$first_name = $1;
			$middle_name = "$2 $3";
			$surname = $4;
		} else {
			if($surname) {
				$surname .= ' ';
			}
			my $rest = $name_components{'non_matching'};
			if($rest =~ /(.+) $/) {
				$rest = $1;
			}
			$surname .= $rest;

			# Remove the middle name, since it's come in from the non_matching
			$middle_name = undef;
			delete $args{'middle_names'};
		}
	} elsif(!defined($surname)) {
		$surname = $self->surname();
	}

	my $has_maiden_name;
	if($args{'nee'}) {
		my $sex = get_value({ person => $self, value => 'sex' });
		if(defined($sex) && ($sex eq 'F')) {
			my @husbands = $self->husband();
			if(my $husband = pop @husbands) {
				$surname = $husband->surname();
				$has_maiden_name = 1;
			} elsif(my $spouse = $self->spouse()) {
				complain({ person => $self, warning => 'married, but no husband relationship' });
				$surname = $spouse->surname();
				$has_maiden_name = 1;
			}
		}
	}

	my $rc;

	if($args{'title'} && $name_components{'title_1'}) {
		$rc = $name_components{'title_1'};
		if($rc) {
			$rc .= ' ';
		}
	}

	if($first_name) {
		$rc .= $first_name;
	} elsif($self->given_names()) {
		$rc .= $self->given_names();
	} elsif($args{'print_unknown'}) {
		$rc .= ' ?';
	}

	if($args{'middle_names'}) {
		if($middle_name) {
			$rc .= " $middle_name";
		} elsif($name =~ /\s([A-Z])\s.+/) {
			# Just an initial has been given
			$rc .= " $1";
		}
	}

	if($surname) {
		if($rc) {
			$rc .= ' ';
		}
		$rc .= normalize_name($surname);
		if(my $suffix = $name_components{'suffix'}) {
			$rc .= " $suffix";
		}
	} elsif($args{'print_unknown'}) {
		$rc .= ' ?';
	}

	if($has_maiden_name && $self->surname()) {
		$rc .= ' (nee ' . normalize_name($self->surname()) . ')';
	}

	if($opts{'w'} && !defined($rc)) {
		complain({ warning => "Can't parse the name of '$name'" });
		$args{'include_years'} = 1;
		$rc = 'Unknown person';
	}

	if($args{'include_years'}) {
		my $dob = dateofbirth($self);

		my $yob;	# Year of birth
		if($dob && ($dob =~ /.*?(\d{3,4})/)) {
			if($dob =~ /^(Abt|ca?)\.?\s*(.+)/i) {
				my $year = $2;
				if($year =~ /^[A-Z]{3}\s(.+)/i) {
					$yob = "c$1";	# Get the "1951" from "Feb 1951"
				}
				$yob = "c$year";
			} else {
				$yob = $1;
			}
		} else {
			$dob = get_value({ person => $self, value => 'baptism date' });
			if($dob && ($dob =~ /.*?(\d{3,4})/)) {
				$yob = "c$1";
			}
		}

		my $dod = dateofdeath($self);

		my $yod;	# Year of death
		if($dod && ($dod =~ /.*?(\d{3,4})/)) {
			if($dod =~ /^(Abt|ca?)\.?\s*(.+)/i) {
				my $year = $2;
				if($year =~ /^[A-Z]{3}\s(.+)/i) {
					$yod = "c$1";	# Get the "1951" from "Feb 1951"
				} else {
					$yod = "c$year";
				}
			} else {
				$yod = $1;
			}
		} else {
			$dod = get_value({ person => $self, value => 'burial date' });
			if($dod && ($dod =~ /.*?(\d{3,4})/)) {
				$yod = "c$1";
			}
		}

		$rc .= ' ' if($yob || $yod);

		if($yob) {
			$rc .= "$yob ";
		}

		$rc .= '-' if($yob || $yod);

		if($yod) {
			return "$rc $yod";
		}
	}

	if(!defined($rc)) {
		complain({ warning => [ "Can't determine the name for record ", $self->xref() ] });
		return '';
	}

	$rc =~ tr/"/'/;	# fix issues with Graphviz and others - compatibility with ged2site

	return $rc;
}

sub Gedcom::Individual::as_sort_key
{
	my $self = shift;
	my $surname = $self->surname();
	my $given_names = $self->given_names();

	if($surname && length($surname)) {
		if($given_names) {
			if($surname =~ /\s(.+?)$/) {
				$surname = $1;
			}
			return normalize_name("$surname, $given_names");
		} else {
			return normalize_name($surname) . ', ZZZZZ';
		}
	} elsif($given_names) {
		return 'ZZZZZ, ' . normalize_name($given_names);
	}

	my $name = $self->name();

	$name =~ s/\///g;
	$nameparser->parse($name);

	my %name_components = $nameparser->components();
	my $first_name = $name_components{'given_name_1'};
	my $middle_name = $name_components{'middle_name'};
	$surname = $name_components{'surname_1'};
	if($name_components{'surname_2'}) {
		$surname .= ' ' . $name_components{'surname_2'};
	}
	my $rest;
	if($name_components{'non_matching'}) {
		if($name =~ /(\w+)\s(\w+)\s(\w+)\s(\w+)$/) {
			# Name parser doesn't parse names like this very well
			$first_name = $1;
			$middle_name = "$2 $3";
			$surname = $4;
		} else {
			if($surname) {
				$surname .= ' ';
			}
			$rest = $name_components{'non_matching'};
			if($rest =~ /(.+) $/) {
				$rest = $1;
			}
		}
	} elsif(!defined($surname)) {
		$surname = $self->surname();
	}

	my $rc;

	if($surname) {
		$rc = normalize_name($surname);
		if(my $suffix = $name_components{'suffix'}) {
			$rc .= " $suffix";
		}
	} else {
		$rc = 'ZZZZZZ';
	}

	if($first_name) {
		$rc .= ", $first_name";
	} elsif($given_names) {
		$rc .= ", $given_names";
	}

	if($middle_name) {
		$rc .= " $middle_name";
	} elsif($name =~ /\s([A-Z])\s.+/) {
		# Just an initial has been given
		$rc .= " $1";
	}

	if($rest) {
		$rc .= $rest;
	}

	if((!defined($rc)) && $opts{'w'}) {
		if($opts{'f'}) {
			die "\nCan't determine the name for record ", $self->xref();
		}
		red_warning({ "Can't determine the name for record " . $self->xref() });
		return '';
	}

	return $rc;
}

sub normalize_name
{
	# my $name = shift;

	# my $rc;
	# foreach my $word(split(/-| |'/, lc($name))) {
		# $rc .= '-' if($rc && ($name =~ /-/));
		# $rc .= "'" if($rc && ($name =~ /'/));
		# $rc .= ' ' if($rc && ($name =~ / /));
		# $rc .= ucfirst($word);
	# }

	# return $rc;

	return Lingua::EN::NameCase::nc(shift);
}

sub Gedcom::Individual::pronoun
{
	my $self = shift;

	my $sex = get_value({ person => $self, value => 'sex' });

	if(defined($sex)) {
		if($sex eq 'F') {
			return 'She';
		}
		if($sex eq 'M') {
			return 'He';
		}
	}
	return 'They';
}

sub Gedcom::Individual::possessive
{
	my $self = shift;

	my $rc = {
		'He' => 'His',
		'She' => 'Her',
		'They' => 'Their',
	};

	return $rc->{$self->pronoun()};
}

# FIXME: currently only finds ancestors
# TODO: find in-laws
# See http://www.myrelative.com/html/relationship.html for inspiration
sub Gedcom::Individual::relationship {
	my $self = shift;
	my $other = shift;

	die $self->as_string() if($other eq $self);

	if($self->mother() && $other->mother() && $self->father() && $other->father()) {
		my $sex = get_value({ person => $other, value => 'sex' });
		if(($self->mother() eq $other->mother()) && ($self->father() eq $other->father())) {
			if($language eq 'French') {
				return ($sex eq 'M') ? 'frère' : 'sœur';
			} else {
				return ($sex eq 'M') ? 'brother' : 'sister';
			}
		}
		if(($self->mother() eq $other->mother()) || ($self->father() eq $other->father())) {
			return ($sex eq 'M') ? 'half-brother' : 'half-sister';
		}
	}

	return $self->relationship_down($other) || $self->relationship_up($other);
}

sub Gedcom::Individual::relationship_up
{
	my $self = shift;
	my $other = shift;
	my @ancestors;

	unless(@myancestors) {
		@myancestors = $self->ancestors();
	}
	if($me && ($self eq $me)) {
		unless(@myancestors) {
			@myancestors = $me->ancestors();
		}
		return unless scalar(@myancestors);
		@ancestors = @myancestors;
	} else {
		@ancestors = $self->ancestors();
	}

	my $sex = get_value({ person => $other, value => 'sex' });
	if((!defined($sex)) || ($sex !~ /[MF]/)) {
		complain({ person => $other, warning => 'unknown sex' });
		return;
	}

	foreach my $person1(@ancestors) {
		die $person1->as_string() if($person1 eq $self);
		if($person1->xref() eq $other->xref()) {
			# Direct ancestor
			my $steps = stepsabove($self, $other, 0);
			my $title;
			if($language eq 'French') {
				$title = ($sex eq 'M') ? 'père' : 'mère';
			} else {
				$title = ($sex eq 'M') ? 'father' : 'mother';
			}
			if($steps >= 5) {
				$steps -= 2;
				return "$steps times great-grand$title";
			} elsif($steps == 1) {
				return $title;
			} elsif($steps == 2) {
				return "grand$title";
			} elsif($steps == 3) {
				return "great-grand$title";
			} elsif($steps == 4) {
				return "great-great-grand$title";
			} elsif($steps <= 0) {
				if(my $spouse = $other->spouse()) {
					if(stepsabove($self, $spouse, 0)) {
						# The caller should now check
						# the spouse's relationship
						return;
					}
				}
				complain({ person => $other, warning => ": BUG - not a direct ancestor, steps = $steps" });
			}
		}
	}

	my @ancestors2 = $other->ancestors();
	return unless(@ancestors2);

	foreach my $person1(@ancestors) {
		foreach my $person2(@ancestors2) {
			# print $person1->as_string(), '->', $person2->as_string(), "\n";
			# G::C is noisy
			# TODO - apparently fixed in Github, awaiting new version on CPAN
			# my $c = Gedcom::Comparison->new($person1, $person2);
			# if($c->identical($person2)) {
				# die 'match found';
			# }

			if($person1 eq $person2) {
				# Common ancestor is $person2
				my $steps1 = stepsabove($self, $person1, 0);
				# die $steps1 if($steps1 > 23);
				return if($steps1 > 23);
				my $steps2 = stepsabove($other, $person2, 0);
				# die $steps2 if($steps2 > 23);
				return if($steps2 > 23);

				# TODO: It would be nice to do this as an algorithm
				my %en_male_relationships = (
					1 << 24 | 1 => 'brother',
					1 << 24 | 2 => 'nephew',
					1 << 24 | 3 => 'great-nephew',
					1 << 24 | 4 => 'great-great-nephew',
					2 << 24 | 1 => 'uncle',
					2 << 24 | 2 => 'cousin',
					2 << 24 | 3 => 'first cousin once-removed',
					2 << 24 | 4 => 'first cousin twice-removed',
					2 << 24 | 5 => 'first cousin three-times-removed',
					3 << 24 | 1 => 'great-uncle',
					3 << 24 | 2 => 'first cousin once-removed',
					3 << 24 | 3 => 'second cousin',
					3 << 24 | 4 => 'second cousin once-removed',
					3 << 24 | 5 => 'second cousin twice-removed',
					3 << 24 | 6 => 'second cousin three-times-removed',
					4 << 24 | 1 => 'great-great-uncle',
					4 << 24 | 2 => 'first cousin twice-removed',
					4 << 24 | 3 => 'second cousin once-removed',
					4 << 24 | 4 => 'third cousin',
					4 << 24 | 5 => 'third cousin once-removed',
					4 << 24 | 6 => 'third cousin twice-removed',
					4 << 24 | 7 => 'third cousin three-times-removed',
					5 << 24 | 1 => 'third times great-uncle',
					5 << 24 | 2 => 'first cousin three-times-removed',
					5 << 24 | 3 => 'second cousin twice-removed',
					5 << 24 | 4 => 'third cousin once-removed',
					5 << 24 | 5 => 'fourth cousin',
					5 << 24 | 6 => 'fourth cousin once-removed',
					5 << 24 | 7 => 'fourth cousin twice-removed',
					6 << 24 | 1 => 'four times great-uncle',
					6 << 24 | 2 => 'first cousin four-times-removed',
					6 << 24 | 3 => 'second cousin three-times-removed',
					6 << 24 | 4 => 'third cousin twice-removed',
					6 << 24 | 5 => 'fourth cousin once-removed',
					6 << 24 | 6 => 'fifth cousin',
					6 << 24 | 7 => 'fifth cousin once-removed',
					6 << 24 | 8 => 'fifth cousin twice-removed',
					7 << 24 | 1 => 'fifth times great-uncle',
					7 << 24 | 2 => 'first cousin five-times-removed',
					7 << 24 | 3 => 'second cousin four-times-removed',
					7 << 24 | 4 => 'third cousin three-times-removed',
					7 << 24 | 5 => 'fourth cousin twice-removed',
					7 << 24 | 6 => 'fifth cousin once-removed',
					7 << 24 | 7 => 'sixth cousin',
					7 << 24 | 8 => 'sixth cousin once-removed',
					8 << 24 | 1 => 'six times great-uncle',
					8 << 24 | 2 => 'first cousin six-times-removed',
					8 << 24 | 3 => 'second cousin five-times-removed',
					8 << 24 | 4 => 'third cousin four-times-removed',
					9 << 24 | 1 => 'seven times great-uncle',
					9 << 24 | 2 => 'first cousin seven-times-removed',
					9 << 24 | 3 => 'second cousin six-times-removed',
					9 << 24 | 4 => 'third cousin five-times-removed',
					10 << 24 | 1 => 'eight times great-uncle',
					10 << 24 | 2 => 'first cousin eight-times-removed',
					10 << 24 | 3 => 'second cousin seven-times-removed',
					10 << 24 | 4 => 'third cousin six-times-removed',
					11 << 24 | 1 => 'nine times great-uncle',
					11 << 24 | 2 => 'first cousin nine-times-removed',
					11 << 24 | 3 => 'second cousin eight-times-removed',
					11 << 24 | 4 => 'third cousin seven-times-removed',
					11 << 24 | 5 => 'fourth cousin six-times-removed',
					12 << 24 | 1 => 'ten times great-uncle',
					12 << 24 | 2 => 'first cousin ten-times-removed',
					12 << 24 | 3 => 'second cousin nine-times-removed',
					12 << 24 | 4 => 'third cousin eight-times-removed',
					12 << 24 | 5 => 'fourth cousin seven-times-removed',
					13 << 24 | 1 => 'eleven times great-uncle',
					14 << 24 | 1 => 'twelve times great-uncle',
					15 << 24 | 1 => 'thirteen times great-uncle',
					16 << 24 | 1 => 'fourteen times great-uncle',
					17 << 24 | 1 => 'fifteen times great-uncle',
					18 << 24 | 1 => 'sixteen times great-uncle',
				);
				my %fr_male_relationships = (
					1 << 24 | 1 => 'frère',
					1 << 24 | 2 => 'neveu',
					1 << 24 | 3 => 'great-nephew',
					1 << 24 | 4 => 'great-great-nephew',
					2 << 24 | 1 => 'oncle',
					2 << 24 | 2 => 'cousin',
					2 << 24 | 3 => 'first cousin once-removed',
					2 << 24 | 4 => 'first cousin twice-removed',
					2 << 24 | 5 => 'first cousin three-times-removed',
					3 << 24 | 1 => 'great-uncle',
					3 << 24 | 2 => 'first cousin once-removed',
					3 << 24 | 3 => 'second cousin',
					3 << 24 | 4 => 'second cousin once-removed',
					3 << 24 | 5 => 'second cousin twice-removed',
					3 << 24 | 6 => 'second cousin three-times-removed',
					4 << 24 | 1 => 'great-great-uncle',
					4 << 24 | 2 => 'first cousin twice-removed',
					4 << 24 | 3 => 'second cousin once-removed',
					4 << 24 | 4 => 'third cousin',
					4 << 24 | 5 => 'third cousin once-removed',
					4 << 24 | 6 => 'third cousin twice-removed',
					4 << 24 | 7 => 'third cousin three-times-removed',
					5 << 24 | 1 => 'third times great-uncle',
					5 << 24 | 2 => 'first cousin three-times-removed',
					5 << 24 | 3 => 'second cousin twice-removed',
					5 << 24 | 4 => 'third cousin once-removed',
					5 << 24 | 5 => 'fourth cousin',
					5 << 24 | 6 => 'fourth cousin once-removed',
					5 << 24 | 7 => 'fourth cousin twice-removed',
					6 << 24 | 1 => 'four times great-uncle',
					6 << 24 | 2 => 'first cousin four-times-removed',
					6 << 24 | 3 => 'second cousin three-times-removed',
					6 << 24 | 4 => 'third cousin twice-removed',
					6 << 24 | 5 => 'fourth cousin once-removed',
					6 << 24 | 6 => 'fifth cousin',
					6 << 24 | 7 => 'fifth cousin once-removed',
					6 << 24 | 8 => 'fifth cousin twice-removed',
					7 << 24 | 1 => 'five times great-uncle',
					7 << 24 | 2 => 'first cousin five-times-removed',
					7 << 24 | 3 => 'second cousin four-times-removed',
					7 << 24 | 4 => 'third cousin three-times-removed',
					7 << 24 | 5 => 'fourth cousin twice-removed',
					7 << 24 | 6 => 'fifth cousin once-removed',
					7 << 24 | 7 => 'sixth cousin',
					7 << 24 | 8 => 'sixth cousin once-removed',
					8 << 24 | 1 => 'six times great-uncle',
					8 << 24 | 2 => 'first cousin six-times-removed',
					8 << 24 | 3 => 'second cousin five-times-removed',
					8 << 24 | 4 => 'third cousin four-times-removed',
					9 << 24 | 1 => 'seven times great-uncle',
					9 << 24 | 2 => 'first cousin seven-times-removed',
					9 << 24 | 3 => 'second cousin six-times-removed',
					9 << 24 | 4 => 'third cousin five-times-removed',
					10 << 24 | 1 => 'eight times great-uncle',
					10 << 24 | 2 => 'first cousin eight-times-removed',
					10 << 24 | 3 => 'second cousin seven-times-removed',
					10 << 24 | 4 => 'third cousin six-times-removed',
					11 << 24 | 1 => 'nine times great-uncle',
					11 << 24 | 2 => 'first cousin nine-times-removed',
					11 << 24 | 3 => 'second cousin eight-times-removed',
					11 << 24 | 4 => 'third cousin seven-times-removed',
					11 << 24 | 5 => 'fourth cousin six-times-removed',
					12 << 24 | 1 => 'ten times great-uncle',
					12 << 24 | 2 => 'first cousin ten-times-removed',
					12 << 24 | 3 => 'second cousin nine-times-removed',
					12 << 24 | 4 => 'third cousin eight-times-removed',
					12 << 24 | 5 => 'fourth cousin seven-times-removed',
					13 << 24 | 1 => 'eleven times great-uncle',
					14 << 24 | 1 => 'twelve times great-uncle',
					15 << 24 | 1 => 'thirteen times great-uncle',
					16 << 24 | 1 => 'fourteen times great-uncle',
					17 << 24 | 1 => 'fifteen times great-uncle',
					18 << 24 | 1 => 'sixteen times great-uncle',
				);
				my %en_female_relationships = (
					1 << 24 | 1 => 'sister',
					1 << 24 | 2 => 'niece',
					1 << 24 | 3 => 'great-niece',
					1 << 24 | 4 => 'great-great-niece',
					2 << 24 | 1 => 'aunt',
					2 << 24 | 2 => 'cousin',
					2 << 24 | 3 => 'first cousin once-removed',
					2 << 24 | 4 => 'first cousin twice-removed',
					2 << 24 | 5 => 'first cousin three-times-removed',
					3 << 24 | 1 => 'great-aunt',
					3 << 24 | 2 => 'first cousin once-removed',
					3 << 24 | 3 => 'second cousin',
					3 << 24 | 4 => 'second cousin once-removed',
					3 << 24 | 5 => 'second cousin twice-removed',
					3 << 24 | 6 => 'second cousin three-times-removed',
					4 << 24 | 1 => 'great-great-aunt',
					4 << 24 | 2 => 'first cousin twice-removed',
					4 << 24 | 3 => 'second cousin once-removed',
					4 << 24 | 4 => 'third cousin',
					4 << 24 | 5 => 'third cousin once-removed',
					4 << 24 | 6 => 'third cousin twice-removed',
					4 << 24 | 7 => 'third cousin three-times-removed',
					5 << 24 | 1 => 'third times great-aunt',
					5 << 24 | 2 => 'first cousin three-times-removed',
					5 << 24 | 3 => 'second cousin twice-removed',
					5 << 24 | 4 => 'third cousin once-removed',
					5 << 24 | 5 => 'fourth cousin',
					5 << 24 | 6 => 'fourth cousin once-removed',
					5 << 24 | 7 => 'fourth cousin twice-removed',
					6 << 24 | 1 => 'four times great-aunt',
					6 << 24 | 2 => 'first cousin four-times-removed',
					6 << 24 | 3 => 'second cousin three-times-removed',
					6 << 24 | 4 => 'third cousin twice-removed',
					6 << 24 | 5 => 'fourth cousin once-removed',
					6 << 24 | 6 => 'fifth cousin',
					6 << 24 | 7 => 'fifth cousin once-removed',
					6 << 24 | 8 => 'fifth cousin twice-removed',
					7 << 24 | 1 => 'five times great-aunt',
					7 << 24 | 2 => 'first cousin five-times-removed',
					7 << 24 | 3 => 'second cousin four-times-removed',
					7 << 24 | 4 => 'third cousin three-times-removed',
					7 << 24 | 5 => 'fourth cousin twice-removed',
					7 << 24 | 6 => 'fifth cousin once-removed',
					7 << 24 | 7 => 'sixth cousin',
					7 << 24 | 8 => 'sixth cousin once-removed',
					8 << 24 | 1 => 'six times great-aunt',
					8 << 24 | 2 => 'first cousin six-times-removed',
					8 << 24 | 3 => 'second cousin five-times-removed',
					8 << 24 | 4 => 'third cousin four-times-removed',
					9 << 24 | 1 => 'seven times great-aunt',
					9 << 24 | 2 => 'first cousin seven-times-removed',
					9 << 24 | 3 => 'second cousin six-times-removed',
					9 << 24 | 4 => 'third cousin five-times-removed',
					10 << 24 | 1 => 'eight times great-aunt',
					10 << 24 | 2 => 'first cousin eight-times-removed',
					10 << 24 | 3 => 'second cousin seven-times-removed',
					10 << 24 | 4 => 'third cousin six-times-removed',
					11 << 24 | 1 => 'nine times great-aunt',
					11 << 24 | 2 => 'first cousin nine-times-removed',
					11 << 24 | 3 => 'second cousin eight-times-removed',
					11 << 24 | 4 => 'third cousin seven-times-removed',
					11 << 24 | 5 => 'fourth cousin six-times-removed',
					12 << 24 | 1 => 'ten times great-aunt',
					12 << 24 | 2 => 'first cousin ten-times-removed',
					12 << 24 | 3 => 'second cousin nine-times-removed',
					12 << 24 | 4 => 'third cousin eight-times-removed',
					12 << 24 | 5 => 'fourth cousin seven-times-removed',
					13 << 24 | 1 => 'eleven times great-aunt',
					14 << 24 | 1 => 'twelve times great-aunt',
					15 << 24 | 1 => 'thirteen times great-aunt',
					16 << 24 | 1 => 'fourteen times great-aunt',
					17 << 24 | 1 => 'fifteen times great-aunt',
					18 << 24 | 1 => 'sixteen times great-aunt',
				);
				my %fr_female_relationships = (
					1 << 24 | 1 => 'sœur',
					1 << 24 | 2 => 'nièce',
					1 << 24 | 3 => 'great-niece',
					1 << 24 | 4 => 'great-great-niece',
					2 << 24 | 1 => 'tant',
					2 << 24 | 2 => 'cousine',
					2 << 24 | 3 => 'first cousin once-removed',
					2 << 24 | 4 => 'first cousin twice-removed',
					2 << 24 | 5 => 'first cousin three-times-removed',
					3 << 24 | 1 => 'great-aunt',
					3 << 24 | 2 => 'first cousin once-removed',
					3 << 24 | 3 => 'second cousin',
					3 << 24 | 4 => 'second cousin once-removed',
					3 << 24 | 5 => 'second cousin twice-removed',
					3 << 24 | 6 => 'second cousin three-times-removed',
					4 << 24 | 1 => 'great-great-aunt',
					4 << 24 | 2 => 'first cousin twice-removed',
					4 << 24 | 3 => 'second cousin once-removed',
					4 << 24 | 4 => 'third cousin',
					4 << 24 | 5 => 'third cousin once-removed',
					4 << 24 | 6 => 'third cousin twice-removed',
					4 << 24 | 7 => 'third cousin three-times-removed',
					5 << 24 | 1 => 'third times great-aunt',
					5 << 24 | 2 => 'first cousin three-times-removed',
					5 << 24 | 3 => 'second cousin twice-removed',
					5 << 24 | 4 => 'third cousin once-removed',
					5 << 24 | 5 => 'fourth cousin',
					5 << 24 | 6 => 'fourth cousin once-removed',
					5 << 24 | 7 => 'fourth cousin twice-removed',
					6 << 24 | 1 => 'four times great-aunt',
					6 << 24 | 2 => 'first cousin four-times-removed',
					6 << 24 | 3 => 'second cousin three-times-removed',
					6 << 24 | 4 => 'third cousin twice-removed',
					6 << 24 | 5 => 'fourth cousin once-removed',
					6 << 24 | 6 => 'fifth cousin',
					6 << 24 | 7 => 'fifth cousin once-removed',
					6 << 24 | 8 => 'fifth cousin twice-removed',
					7 << 24 | 1 => 'fifth times great-aunt',
					7 << 24 | 2 => 'first cousin five-times-removed',
					7 << 24 | 3 => 'second cousin four-times-removed',
					7 << 24 | 4 => 'third cousin three-times-removed',
					7 << 24 | 5 => 'fourth cousin twice-removed',
					7 << 24 | 6 => 'fifth cousin once-removed',
					7 << 24 | 7 => 'sixth cousin',
					7 << 24 | 8 => 'sixth cousin once-removed',
					8 << 24 | 1 => 'six times great-aunt',
					8 << 24 | 2 => 'first cousin six-times-removed',
					8 << 24 | 3 => 'second cousin five-times-removed',
					8 << 24 | 4 => 'third cousin four-times-removed',
					9 << 24 | 1 => 'seven times great-aunt',
					9 << 24 | 2 => 'first cousin seven-times-removed',
					9 << 24 | 3 => 'second cousin six-times-removed',
					9 << 24 | 4 => 'third cousin five-times-removed',
					10 << 24 | 1 => 'eight times great-aunt',
					10 << 24 | 2 => 'first cousin eight-times-removed',
					10 << 24 | 3 => 'second cousin seven-times-removed',
					10 << 24 | 4 => 'third cousin six-times-removed',
					11 << 24 | 1 => 'nine times great-aunt',
					11 << 24 | 2 => 'first cousin nine-times-removed',
					11 << 24 | 3 => 'second cousin eight-times-removed',
					11 << 24 | 4 => 'third cousin seven-times-removed',
					11 << 24 | 5 => 'fourth cousin six-times-removed',
					12 << 24 | 1 => 'ten times great-aunt',
					12 << 24 | 2 => 'first cousin ten-times-removed',
					12 << 24 | 3 => 'second cousin nine-times-removed',
					12 << 24 | 4 => 'third cousin eight-times-removed',
					12 << 24 | 5 => 'fourth cousin seven-times-removed',
					13 << 24 | 1 => 'eleven times great-aunt',
					14 << 24 | 1 => 'twelve times great-aunt',
					15 << 24 | 1 => 'thirteen times great-aunt',
					16 << 24 | 1 => 'fourteen times great-aunt',
					17 << 24 | 1 => 'fifteen times great-aunt',
					18 << 24 | 1 => 'sixteen times great-aunt',
				);

				my $rc;
				if($language eq 'French') {
					$rc = ($sex eq 'M') ?
						$fr_male_relationships{($steps1 << 24) | $steps2} :
						$fr_female_relationships{($steps1 << 24) | $steps2};
				} else {
					$rc = ($sex eq 'M') ?
						$en_male_relationships{($steps1 << 24) | $steps2} :
						$en_female_relationships{($steps1 << 24) | $steps2};
				}
				if(defined($rc) && ($rc =~ /cousin/)) {
					my $myfather = $self->father();
					my $mymother = $self->mother();
					if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
						if($me && ($self eq $me)) {
							if($language eq 'French') {
								$rc .= " sur votre père's side";
							} else {
								$rc .= " on your father's side";
							}
						} else {
							$rc .= ' on ' .
								lcfirst($self->possessive()) .
								" father's side";
						}
					} elsif($mymother && (stepsabove($mymother, $person2, 0) > 0)) {
						if($me && ($self eq $me)) {
							if($language eq 'French') {
								$rc .= " sur votre mère's side";
							} else {
								$rc .= " on your mother's side";
							}
						} else {
							$rc .= ' on ' .
								lcfirst($self->possessive()) .
								" mother's side";
						}
					}
				}
				if(!defined($rc)) {
					# die $other->as_string(), ": $steps1, $steps2";
					complain({ person => $other, warning => "TODO: $steps1, $steps2" });
				}
				return $rc;
			}
		}
	}
}

sub Gedcom::Individual::relationship_down
{
	my $self = shift;
	my $other = shift;
	my @descendents;

	if($me && ($self eq $me)) {
		unless(@mydescendents) {
			@mydescendents = $me->descendents();
		}
		return unless scalar(@mydescendents);
		@descendents = @mydescendents;
	} else {
		@descendents = $self->descendents();
	}

	my $sex = get_value({ person => $other, value => 'sex' });
	if((!defined($sex)) || ($sex !~ /[MF]/)) {
		complain({ person => $other, warning => 'unknown sex' });
		return;
	}

	# print __LINE__, ': ', $self->as_string(), '/', $other->as_string(), "\n";
	foreach my $person1(@descendents) {
		# print __LINE__, "\t", $person1->as_string(), "\n";
		die if($person1 eq $self);
		if($person1 eq $other) {
			# Direct desendent
			my $steps = stepsabove($other, $self, 0);
			my $title = ($sex eq 'M') ? 'son' : 'daughter';
			if($steps >= 5) {
				$steps -= 2;
				return "$steps times great-grand$title";
			} elsif($steps == 1) {
				if($language eq 'French') {
					if($sex eq 'M') {
						return 'fils';
					}
				}
				return $title;
			} elsif($steps == 2) {
				if($language eq 'French') {
					if($sex eq 'M') {
						return 'petit-fils';
					}
				}
				return "grand$title";
			} elsif($steps == 3) {
				if($language eq 'French') {
					if($sex eq 'M') {
						return 'arrière-petit-fils';
					}
				}
				return "great-grand$title";
			} elsif($steps == 4) {
				return "great-great-grand$title";
			} elsif($steps <= 0) {
				if(my $spouse = $other->spouse()) {
					if(stepsabove($self, $spouse, 0)) {
						# The caller should now check
						# the spouse's relationship
						return;
					}
				}
				complain({ person => $other, warning => ": BUG - not a direct ancestor, steps = $steps" });
			}
		}
	}
}

sub stepsabove
{
	my $person = shift;
	my $target = shift;
	my $count = shift;

	return -1 if($count == -1);

	if($person->xref() eq $target->xref()) {
		return $count;
	}

	my @father = $person->father();
	if(my $father = $father[0]) {
		my $rc = stepsabove($father, $target, $count + 1);
		return $rc if($rc != -1);
	}

	my @mother = $person->mother();
	if(my $mother = $mother[0]) {
		return stepsabove($mother, $target, $count + 1);
	}

	return -1;
}

sub year
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $string = $params{'string'} || $params{'date'};

	if(!defined($string)) {
		$string = $params{'record'};
		return unless($string);

		if(ref($string) eq 'Gedcom::Record') {
			$string = $string->date();
			return unless($string);
		}
	}

	if($string =~ /^\d{3,4}$/) {
		if($language eq 'French') {
			return "en $string";
		}
		return "in $string";
	}
	if($string =~ /^(Abt|ca?)\.?\s*(.+)/i) {
		my $rc = $2;
		if($opts{'w'}) {
			if(my $must_postdate = $params{'must_postdate'}) {
				my $dt;
				if($rc !~ /^\d/) {
					$dt = date_to_datetime("1 $rc");
				} else {
					$dt = date_to_datetime($rc);
				}
				if($dt && ($dt < $must_postdate)) {
					complain({ person => $params{'person'}, warning => "Something is wrong with the date $string which should be after $must_postdate" });
				}
			}
			if(my $must_predate = $params{'must_predate'}) {
				my $dt;
				if($rc !~ /^\d/) {
					$dt = date_to_datetime("1 $rc");
				} else {
					$dt = date_to_datetime($rc);
				}
				if($dt && ($dt > $must_predate)) {
					complain({ person => $params{'person'}, warning => "Something is wrong with the date $string which should be before $must_predate" });
				}
			}
		}
		if($params{'circa'}) {
			return $params{'circa'} . " $rc";
		}
		return "c. $rc";
	}
	if(($string =~ /^bet (.+) and (.+)/i) ||
	   ($string =~ /^Fro?m (.+) to (.+)/i)) {
		my $from = year({ %params, string => $1 });
		my $to = year({ %params, string => $2 });
		$from =~ s/^(in|on|c.) //;
		$to =~ s/^(in|on|c.) //;
		if($language eq 'French') {
			return "de $from à $to";
		}
		return "from $from to $to";
	}

	if($string =~ /(.+)\s(\d{4})\/\d{2}/) {
		my $year = $2 + 1;
		complain({ person => $params{'person'}, warning => "old-style date ($string) should be in $year" });
		$string = "$1 $year";
	}

	if(($string =~ /^\d/) && ($string !~ /[a-z]$/i)) {
		my $person = $params{'person'};
		if($string =~ /^31 Nov/) {
			complain({ person => $person, warning => "$string is invalid, there are only 30 days in November" });
			return;
		}
		if(my $d = date_parser_cached(date => $string)) {
			$d = $dfn->parse_datetime($d->{'canonical'});
			if(my $must_postdate = $params{'must_postdate'}) {
				complain({
					person => $person,
					warning => [ "Something is wrong with the date $string which should be after ", $must_postdate->strftime('%x') ],
					# stack_trace => 1,
				}) if($d < $must_postdate);
			}
			if(my $must_predate = $params{'must_predate'}) {
				complain({ person => $person, warning => "Something is wrong with the date $string which should be before " . $must_predate->strftime('%x') }) if($d > $must_predate);
			}
			return 'on ' . $d->strftime('%x');
		}
		if($@) {
			# RT 107354
			chomp $@;
			if($opts{'f'}) {
				if($person) {
					die $person->as_string(), ": $@";
				}
				die $@;
			}
			if($opts{'w'}) {
				red_warning({ person => $person, warning => $@ });
			}
		}
		if($language eq 'French') {
			return "en $string";
		}
		return "on $string";
	}
	if($string =~ /^bef.? (\d{3,4})/i) {
		if($language eq 'French') {
			return "avant $1";
		}
		return "before $1";
	}
	if($string =~ /^by.? (\d{3,4})/i) {
		return "by $1";
	}
	if($string =~ /^By (\d{3,4})/i) {
		if(my $person = $params{'person'}) {
			complain({ person => $person, warning => "says 'By' instead of 'Bef'" });
		} else {
			complain("says 'By' instead of 'Bef'");
		}
		if($language eq 'French') {
			return "avant $1";
		}
		return "before $1";
	}
	if($string =~ /^aft.? (\d{3,4})/i) {
		if($language eq 'French') {
			return "après $1";
		}
		return "after $1";
	}

	$string = ucfirst(lc($string));
	if($params{'nopreposition'}) {
		return $string;
	}
	if($language eq 'French') {
		return ($string =~ /\d$/) ? "en $string" : "le $string";
	}
	return ($string =~ /\d$/) ? "in $string" : "on $string";
}

# TODO: Use Locale::Country::Multilingual
sub place {
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $place = $params{'place'};
	my $address = $params{'address'};

	if(!defined($place)) {
		$place = $params{'record'};
		return unless($place);

		if(ref($place) eq 'Gedcom::Record') {
			my $p = $place;
			$address = $place->address();
			if(ref($address) eq 'Gedcom::Record') {
				$place = getaddress($address);
				$address = undef;
			} else {
				$place = $place->place();
			}
			if(!defined($place)) {
				if(!$params{'allow_empty'}) {
					if(my $date = $p->date()) {
						if($date =~ /^bet\s*(.+)/i) {
							complain({ person => $params{'person'}, warning => "Location for the event between $1 is empty" });
						} else {
							complain({ person => $params{'person'}, warning => "Location for the event on $date is empty" });
						}
					} else {
						complain({ person => $params{'person'}, warning => 'Location is empty' });
					}
				}
				return;
			}
		}
	} elsif(ref($address) eq 'Gedcom::Record') {
		$place = getaddress($address);
		$address = undef;
	}

	if((!defined($address)) &&
	   ($place !~ /USA$/) && ($place !~ /United States$/) &&
	   ($place =~ /(.+),\s*(.+,\s*.+,\s*.+)$/)) {
		$address = $1;
		$place = $2;
	}

	# Google maps (and possibly others) sometimes works better with full names
	if($address) {
		if($address =~ /(.+)\sSt\.?$/) {
			$address = "$1 Street";
		} elsif($address =~ /(.+)\sAve\.?$/) {
			$address = "$1 Avenue";
		} elsif($address =~ /(.+)\sRd\.?$/) {
			$address = "$1 Road";
		}
	}

	my $there = $params{'there'};

	if($there && ($place eq $there)) {
		if($address) {
			if($place =~ /^(.+?),.+,/) {
				if($params{'nopreposition'}) {
					return " $address, $1";
				} elsif($language eq 'French') {
					return " à $address, $1";
				} else {
					return " at $address, $1";
				}
			}
		} else {
			return ' there';
		}
	}

	# The more consistent the data, the fewer lookups on Geocoders and the smoother the English output
	if($place =~ /(.+?)\s*United States$/i) {
		$place = "$1 USA";
	} elsif($place =~ /States\s*$/) {
		complain({ person => $params{'person'}, warning => "Unexpected text at the end of the place '$place'" });
	}

	if($params{'person'}) {
		validate_place({ person => $params{'person'}, place => $place });
	}

	if($birth_country && (!$opts{'T'}) && ($place =~ /(.+),\s*\Q$birth_country\E$/i)) {
		$place = $1;
	}

	if((!$opts{'T'}) && $place =~ /^\d/) {
		if(my $places_printed = $params{'places_printed'}) {
			$places_printed->{" at$place"} = 1;
			if($place =~ /(.+),(.+?),(.+?),(.+?),(.+?)$/) {
				if($places_printed->{" in$3,$4,$5"}) {
					$places_printed->{"in $1,$2,$3"} = 1;
					if($language eq 'French') {
						return " à $1,$2,$3";
					}
					return " at $1,$2,$3";
				}
			}
			if($place =~ /(.+),(.+?),(.+?),(.+?)$/) {
				$places_printed->{" in$2,$3,$4"} = 1;
			}
		}
		if($language eq 'French') {
			return " à $place";
		}
		return " at $place";
	}

	if($place eq 'USA') {
		if($language eq 'French') {
			if($params{'nopreposition'}) {
				return ' États-Unis';
			}
			return ' aux États-Unis';
		}
		if($params{'nopreposition'}) {
			return ' USA';
		}
		return ' in the USA';
	}

	if($address) {
		if($params{'nopreposition'}) {
			$place = " $address, $place";
		} elsif($language eq 'French') {
			$place = " à $address, $place";
		} else {
			$place = " at $address, $place";
		}
	} elsif($params{'nopreposition'}) {
		$place = " $place";
	} elsif($place =~ /^Isle of /) {
		$place = " on the $place";
	} elsif(($language eq 'French') && ($place =~ /,/)) {
		$place = " à $place";
	} else {
		$place = " in $place";
	}

	# Only print the town if the location has already been printed
	if((!$opts{'T'}) && (my $places_printed = $params{'places_printed'})) {
		if($places_printed->{$place} && $place =~ /^(.+?),/) {
			return $1;
		}
		if($place =~ /(.+),(.+?),(.+?),(.+?)$/) {
			my $str = "$2,$3,$4";
			if($params{'person'}) {
				validate_place({ person => $params{'person'}, place => $place });
			}
			if($places_printed->{" in$str"}) {
				if(($4 eq ' USA') || ($4 eq ' Canada')) {
					return "$1,$3";
				}
				return $address ? "$1,$2" : "$1 in$2";
			}
			if($places_printed->{" at$str"}) {
				return "$1,$2";
			}
			$str = "$3,$4";
			if($places_printed->{" in$str"}) {
				return "$1,$2,$3";
			}
			if($places_printed->{" at$str"}) {
				return "$1,$2,$3";
			}
			$places_printed->{" in$str"} = 1;
			$places_printed->{" in$2,$3,$4"} = 1;
		} elsif($place =~ /(.+),(.+),(.+)$/) {
			if($places_printed->{" in$2,$3"}) {
				# We did place, county, country before, so just
				# return place, county
				return "$1,$2";
			}
			$places_printed->{" in$2,$3"} = 1;
		}
		$places_printed->{$place} = 1;
	}
	if(!defined($params{'encode'})) {
		$params{'encode'} = 0;
	}
	if($ENV{'LANG'}) {
		if($place =~ /(.*),\s+([A-Z\s]+)$/i) {
			if(my $code = $lcm->country2code($2)) {
				$place = "$1, " . $lcm->code2country($code, $ENV{'LANG'});
			} elsif(($2 eq 'England') && ($language eq 'French')) {
				$place = "$1, Angleterre";
			}
		} elsif($place !~ /,/) {
			if(my $code = $lcm->country2code($place)) {
				$place = $lcm->code2country($code, $ENV{'LANG'});
			}
		}
	}
	if($params{'encode'}) {
		return HTML::Entities::encode($place);
	}
	return $place;
}

sub getaddress {
	my $address = shift;

	my $rc;

	if(my $city = $address->city()) {
		$rc = $city;
	}
	if(my $state = $address->state()) {
		if($rc) {
			$rc .= ', ';
		}
		$rc .= $state;
	}
	if(my $country = $address->country()) {
		if($rc) {
			$rc .= ', ';
		}
		$rc .= $country;
	}

	return $rc;
}

# paragraph => 1: ignore spacing and put it all into one paragraph
sub notes {
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $record = $params{'record'};
	my $paragraph = $params{'paragraph'};
	my @notes = $record->get_record('note');

	# my @deathnotes = get_value({ person => $person, value => 'death note' });
	my $rc = $record->get_value();
	$rc .= '.' if($rc && !scalar(@notes));

	foreach my $note(@notes) {
		if($note) {
			if(ref($note) eq 'Gedcom::Record') {
				$note = $note->full_value();	# Include CONC records
			} else {
				complain("Note record is just description ($note), infomation may have been lost");
			}
			$note =~ s/\r//g;
			next if($note =~ /^\s*$/);
			if(!$paragraph) {
				$note =~ s/\n+/; /g;
			}
			$note =~ s/\s\s+/ /g;
			$note =~ s/\s+$//g;
			$note =~ s/\. /.  /g;
			$note =~ s/Dr\.\s\s/Dr. /g;
			$note =~ s/Mrs\.\s\s/Mrs. /g;
			$note =~ s/Rev\.\s\s/Rev. /g;
			$note =~ s/St\.\s\s/St. /g;
			$note =~ s/([A-Z]\.\s)\s/$1/g;
			if($paragraph) {
				if($rc) {
					$rc .= "\n";
				}
				if($opts{'B'}) {
					$rc .= '    ';
				} else {
					$rc .= "\t";
				}
			} elsif($rc) {
				$rc =~ s/\.$//;
				$rc .= '; ';
			}
			$rc .= $note;
			$rc .= '.' if($note !~ /\.$/);
		} else {
			complain('Notes field is empty');
		}
	}
	if((!defined($rc)) || (length($rc) == 0)) {
		return;
	}
	$rc =~ s/([\.:]); /$1  /g;
	$rc =~ s/\s+$//;
	$rc =~ s/\xe2\x80\x9c/"/g;	# left quotation
	$rc =~ s/\xe2\x80\x9d/"/g;	# right quotation
	$rc =~ s/\x80"/"/g;
	$rc =~ s/\xe2\x80\x99/'/g;
	$rc =~ s/[\x93\x94]/"/g;
	$rc =~ s/[\x91\x92]/'/g;
	$rc =~ s/[\xc2\xe2]//g;

	if($language eq 'English') {
		if($ENV{'LANG'} =~ /^en_US/) {
			$rc = Lingua::EN::ABC::b2a($rc);
		} elsif($ENV{'LANG'} =~ /^en_CA/) {
			$rc = Lingua::EN::ABC::b2c($rc);
		} else {
			$rc = Lingua::EN::ABC::a2b($rc);
		}
	}

	# my $region;

	# if($record) {
		# $region = $record->place();
	# }
	# if(!$region && (my $person = $params{'person'})) {
		# $region = get_value({ person => $person, value => 'birth place' });
		# if(!$region) {
			# $region = get_value({ person => $person, value => 'death place' });
		# }
	# }
	# if($region && ($region =~ /^.+,\s([[a-z\s]+)$/i)) {
		# if($1 =~ /(England|United Kingdom)/i) {
			# $region = 'gb';
		# } elsif($1 =~ /(USA|US|United States)/i) {
			# $region = 'us';
		# } elsif(lc($1) eq 'Canada') {
			# $region = 'ca';
		# }
	# }

	# my @call_details = caller(0);
	# print 'line ', $call_details[2], ">>>>$region\n";
	# foreach my $k(keys %params) {
		# print "\t$k\n";
	# }
	# if(($rc !~ /^was /i) && (my @hr = $textgeocoder->geocode(scantext => $rc, region => $region))) {
		# print STDERR Data::Dumper->new([\@hr])->Dump();
	# }
	return $rc;
}

sub validate_place
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $place = $params{'place'};
	if(!$place) {
		print STDERR "\n";
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'place is not optional';
	}

	$place =~ s/^\s+//;
	$place =~ s/^at\s+//;
	if(defined($places{$place})) {
		return $places{$place};
	}

	# US and Canada are more logical, using city,county,state,country, than other countries
	if($opts{'w'} && (($place !~ /,.*,.*,.*/) || ($place =~ /USA|Canada/i))) {
		if($place =~ /(.*),\s*Independent Cities\s*(.*)/i) {
			$place = "$1$2";
		}
		$place =~ s/^(in|at)\s//;
		if(defined($places{$place})) {
			return $places{$place};
		}
		# my $ap;
		# my $p = $place;
		# if(($place =~ /USA$/) || ($place =~ /United States$/)) {
			# $ap = Lingua::EN::AddressParse->new(country => 'US', auto_clean => 1, force_case => 1, force_post_code_flag => 0);
		# } elsif($place =~ /England$/) {
			# $ap = Lingua::EN::AddressParse->new(country => 'GB', auto_clean => 1, force_case => 1, force_post_code_flag => 0);
			# $p .= ', United Kingdom';
		# }
		# if($ap) {
			# my $error = $ap->parse("$address, $p");
			# print $ap->report();
		# }

		# if(($place =~ /USA$/) || ($place =~ /United States$/)) {
			# if(my $href = Geo::StreetAddress::US->parse_location($place)) {
				# if($href->{'state'} && !$us->{code2state}{$href->{'state'}} && !$us->{state2code}{$href->{'state'}}) {
				# die $href->{'state'};
					# complain({ person => $params{'person'}, warning => "Unknown state in $place" });
				# }
			# }
		# }
		if((($place =~ /USA$/) || ($place =~ /United States$/) || ($place =~ /U\.S\.A\./)) &&
		    ($place =~ /^.+,\s*([\w\s]+),[\w\s]+$/)) {
			my $state = uc($1);
			if((!$us->{code2state}{$state}) && !$us->{state2code}{$state}) {
				complain({ person => $params{'person'}, warning => "Unknown state '$state' in $place" });
			} elsif($place =~ /\sWard \d+,/) {
				complain({ person => $params{'person'}, warning => "Census ward number left in location '$place'" });
			}
		}

		if($opts{'w'}) {
			# Strange locations in censuses
			if($place =~ /Royal Navy/) {
				return 0;
			}
			print "Look up location $place\n", if($opts{'v'});
			# Force wantarray for improved caching in
			# G:C:L
			if(($place eq 'England') || ($place eq 'Scotland')) {
				$place = 'United Kingdom';
			} elsif($place eq 'U.S.A.') {
				$place = 'USA';
			}
			my @locations = $geocoder->geocode($place);
			if(scalar(@locations) == 0) {
				# Don't die because there are many
				# false positives as locations
				# may no longer exist
				if(my $person = $params{'person'}) {
					if($opts{'W'}) {
						print STDERR $person->as_string({ include_years => 1 }), ": unknown location '$place'\n";
					} else {
						my @call_details = caller(0);
						warn colored($person->as_string({ include_years => 1 }) . ": unknown location '$place' at line " . $call_details[2], 'red');
					}
				} else {
					if($opts{'W'}) {
						print STDERR "Unknown location $place\n";
					} else {
						warn colored("Unknown location $place", 'red');
					}
				}
				$places{$place} = 0;
				return 0;
			} elsif(($place !~ /,/) && (!country2code($place))) {
				if(my $person = $params{'person'}) {
					complain({ person => $person, warning => "Country not included in country, or misspelt country '$place'" });
				} else {
					complain("Country not included in country, or misspelt country '$place'");
				}
				$places{$place} = 0;
				return 0;
			}
		}
	}
	$places{$place} = 1;
	return 1;
}

sub places_are_the_same
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $record1 = $params{'first'};
	my $record2 = $params{'second'};

	die 'first is not optional' unless $record1;
	die 'second is not optional' unless $record2;

	my $place1 = $record1->place();
	return 0 unless(defined($place1));
	my $place2 = $record2->place();
	return 0 unless(defined($place2));

	my $person = $params{'person'};
	if($person) {
		validate_place({ person => $person, place => $place1 });
		validate_place({ person => $person, place => $place2 }) unless($place1 eq $place2);
	}

	if($place1 =~ /(.+?)\s*United States$/i) {
		$place1 = "$1 USA";
	}
	if(my $address = $record1->address()) {
		$place1 = "$address, $place1";
	}
	if(my $address = $record2->address()) {
		$place2 = "$address, $place2";
	}
	if($place2 =~ /(.+?)\s*United States$/i) {
		if($person) {
			complain({ person => $person, warning => "Changing 'United States' to 'USA' in $place2" });
		} else {
			complain("Changing 'United States' to 'USA' in $place2");
		}
		$place2 = "$1 USA";
	}
	if($place2 =~ /(.+)\sSt\.?$/) {
		if($person) {
			complain({ person => $person, warning => "Changing 'St' to 'Street' in $place2" });
		} else {
			complain("Changing 'St' to 'Street' in $place2");
		}
		$place2 = "$1 Street";
	} elsif($place2 =~ /(.+)\sAve\.?$/) {
		if($person) {
			complain({ person => $person, warning => "Changing 'Ave' to 'Avenue' in $place2" });
		} else {
			complain("Changing 'Ave' to 'Avenue' in $place2");
		}
		$place2 = "$1 Avenue";
	} elsif($place2 =~ /(.+)\sRd\.?$/) {
		if($person) {
			complain({ person => $person, warning => "Changing 'Rd' to 'Road' in $place2" });
		} else {
			complain("Changing 'Rd' to 'Road' in $place2");
		}
		$place2 = "$1 Road";
	}
	return 1 if($place1 eq $place2);
	if(compare($place1, $place2) > 0.5) {
		if($person) {
			complain({ $person => $person, warning => "The places '$place1' and '$place2' seem similar; is there a typo?" });
		} else {
			complain("The places '$place1' and '$place2' seem similar; is there a typo?");
		}
	}
	return 0;
}

sub print_sibling_baptism
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};
	my $siblings = $params{'siblings'};
	my $date = $params{'date'};
	my $birthdate = $params{'birthdate'};

	return '' if(scalar(@{$siblings}) == 0);

	my @onsameday;
	foreach my $sibling(@{$siblings}) {
		my $dateofsiblingbaptism = get_value({ person => $sibling, value => 'baptism date' });
		if($dateofsiblingbaptism && ($dateofsiblingbaptism eq $date)) {
			push @onsameday, $sibling;
		}
	}
	my $allsamesex = 1;
	if(scalar(@onsameday) > 1) {
		foreach my $sibling(@onsameday) {
			if($sibling->sex() ne $person->sex()) {
				$allsamesex = 0;
				last;
			}
		}
		if($allsamesex) {
			foreach my $sibling(@onsameday) {
				my $dateofsiblingbirth = dateofbirth($sibling);
				if($dateofsiblingbirth && $birthdate && ($dateofsiblingbirth eq $birthdate)) {
					$allsamesex = 0;	# Fudge to force special twin handler
				}
			}
		}
	} else {
		$allsamesex = 0;
	}

	if($allsamesex) {
		return ', the same day as ' . lcfirst($person->possessive()) . ' ' .
			($onsameday[0]->sex() eq 'M' ? 'brothers ' : 'sisters ') .
			Lingua::EN::Inflect::WORDLIST((map { $_->given_names() } @onsameday), {final_sep => ''});
	}
	my $count = 0;
	my $rc = '';
	foreach my $sibling(@onsameday) {
		if($count == 0) {
			$rc .= ', the same day as ';
		} elsif($count < (scalar(@onsameday) - 1)) {
			$rc .= ', ';
		} elsif($count == (scalar(@onsameday) - 1)) {
			$rc .= ' and ';
		}
		$rc .= lcfirst($person->possessive()) . ' ';
		my $dateofsiblingbirth = dateofbirth($sibling);
		if($dateofsiblingbirth && $birthdate && ($dateofsiblingbirth eq $birthdate)) {
			$rc .= 'twin ';
		}
		$rc .= ($sibling->sex() eq 'M' ? 'brother ' : 'sister ') .
			$sibling->given_names();
		$count++;
	}
	return $rc;
}

sub complain
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'warning'} = shift;
	}

	if(!defined($params{'warning'})) {
		my @call_details = caller(0);
		die "What do you want to say on line $call_details[2]?";
	}

	# Support warning being a ref to an array
	if(ref($params{'warning'}) eq 'ARRAY') {
		$params{'warning'} = join('', @{$params{'warning'}});
	}
	if($opts{'f'}) {
		my @call_details = caller(0);
		if($params{'person'}) {
			die $params{'person'}->as_string(), ': ', ucfirst($params{'warning'}), ' at line ', $call_details[2];
		}
		die ucfirst($params{'warning'}), ' at line ', $call_details[2];
	}

	if($opts{'w'}) {
		$params{'caller'} = 1;
		red_warning(%params);
	}
}

sub red_warning
{
	if($opts{'w'}) {
		my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

		my @call_details = caller($params{'caller'} || 0);
		if($opts{'B'}) {
			my $text = $pdfpage->text();
			$text->fillcolor('red');

			my $message;
			if($params{'person'}) {
				$message = $params{'person'}->as_string(middle_names => 1) . ': ' . $params{'warning'};
			} else {
				$message = params{'warning'};
			}
			if(!pdfprint(string => $message, text => $text, pdfpage => $pdfpage)) {
				$text->textend();

				$pdfpage = PDFPage->new();

				$text = $pdfpage->text();
				$text->font($pdf->corefont('Times-Roman'), 12);
				$text->fillcolor('red');
				pdfprint(string => $message, text => $text, pdfpage => $pdfpage);
			}
			$text->fillcolor('black');
		} elsif($params{'person'}) {
			if($opts{'W'}) {
				print STDERR $params{'person'}->as_string(middle_names => 1), ': ', $params{'warning'}, "\n";
			} else {
				warn colored(['red'], $params{'person'}->as_string(middle_names => 1), ': ', $params{'warning'}, ' at line ', $call_details[2]);
			}
		} else {
			if($opts{'W'}) {
				print STDERR $params{'warning'}, "\n";
			} else {
				warn colored(['red'], $params{'warning'}, ' at line ', $call_details[2]);
			}
		}
		if($params{'stack_trace'}) {
			my $i = 0;
			while((my @call_details = (caller($i++)))) {
				print STDERR "\t", colored($call_details[1] . ':' . $call_details[2] . ' calling function ' . $call_details[3], 'red'), "\n";
			}
		}
	}
}

# Cache gedcom values
sub get_value
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	# if($fetcher) {
		# my $args = {
			# object => $params{'person'},
			# message => 'get_value',
			# arg => $params{'value'}
		# };

		# # Doesn't use the prefetching feature, but will automatically cache which is nice
		# # $fetcher->prime($args);
		# return $fetcher->get($args);
	# }
	my $person = $params{'person'};
	if(!defined($person)) {
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'BUG: person argument is mandatory';
	}
	return $params{'person'}->get_value($params{'value'});
}

sub get_source
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	# my $args = {
		# object => $params{'gedcom'},
		# message => 'get_source',
		# arg => $params{'source'}
	# };

	# # Doesn't use the prefetching feature, but will automatically cache which is nice
	# # $fetcher->prime($args);
	# return $fetcher->get($args);
	if(ref($params{'source'})) {
		if($params{'source'}->title()) {
			return $params{'source'};
		}
		return;
	}
	return $params{'gedcom'}->get_source($params{'source'});
}

sub must_predate
{
	return unless($opts{'w'});

	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};
	my $date = $params{'date'};
	my $predate = $params{'predate'};

	return unless($params{'predate'} && $params{'date'});

	my $d1 = $dfn->parse_datetime($date);
	my $d2 = $dfn->parse_datetime($predate);

	if($d1->year() > $d2->year()) {
		complain({
			person => $person,
			warning => "Something is wrong with the date $date which should be before $predate"
		});
	}
}

sub is_alive
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'person'} = shift;
	}

	my $person = $params{'person'};

	if($person->get_record('death') || dateofdeath($person)) {
		return 0;
	}
	if($person->get_record('burial')) {
		return 0;
	}
	my $dob = dateofbirth($person);

	if(!defined($dob)) {
		return 0;	# Err on the side of caution
				# TODO: Look at children's lifespan for a clue
	}

	my $year = (localtime)[5];
	$year += 1900 if($year < 1900);

	if(($dob =~ /^\d{3,4}$/) && ($dob < ($year - 100))) {
		return 0;
	}
	if($dob =~ /^abt (\d{4})$/i) {
		$dob = $1;
	}
	if(($dob =~ /^\d/) && ($dob !~ /[a-z]$/i)) {
		if(my $d = date_parser_cached(date => $dob)) {
			$d = $dfn->parse_datetime($d->{'canonical'});
			if($d->strftime('%Y') < ($year - 120)) {
				return 0;
			}
		}
	}
	return 1;
}

sub make_filename_from_person
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};

	my $rc = $person->as_string(include_years => 1);
	$rc =~ tr/ /-/s;
	$rc =~ tr/"/'/s;
	$rc =~ s/--+/-/g;
	# $rc =~ s/--/-/g;
	$rc =~ s/-$//;

	return "$rc.html";
}

# Parse Gedcom format dates
# Genealogy::Gedcom::Date is expensive, so cache results
sub date_parser_cached
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'date'} = shift;
	}

	my $date = $params{'date'};

	if($date =~ /^([A-Z]{3})\s+(\d{1,2}),\s+(\d{3,4})$/i) {
		complain(warning => "Changing US format date '$date' to Gedcom format '$2 $1 $3'");
		$date = "$2 $1 $3";
	}

	if($all_dates{$date}) {
		print "$date is already known\n" if($opts{'v'});
		return $all_dates{$date};
	}
	if($date !~ /\d$/) {
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'BUG: illegal date should have been trapped by now';
	}
	print "Parse date $date\n" if($opts{'v'});
	my $d;
	eval {
		$d = $date_parser->parse(date => $date);
	};
	if($d && (ref($d) eq 'ARRAY')) {
		$d = @{$d}[0];
		$all_dates{$date} = $d;
	}
	return $d;
}

# Try hard to convert a Gedcom date to a DateTime object.
# If a date range is given, return a two element array in array context, or undef in scalar context
sub date_to_datetime
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'date'} = shift;
	}

	if(my $date = $params{'date'}) {
		if($date =~ /^\s*(\d{3,4})\s*\-\s*(\d{3,4})\s*$/) {
			complain("Changing date '$date' to 'bet $1 and $2'");
			$date = "bet $1 and $2";
		}
		if($date =~ /^bet (.+) and (.+)/i) {
			if(wantarray) {
				my $rc0 = date_to_datetime($1);
				my $rc1 = date_to_datetime($2);
				if($rc0 < $rc1) {
					return ($rc0, $rc1);
				}
				complain("Invalid date range $date");
			}
			return;
		}
		if($date !~ /^\d{3,4}$/) {
			if($date =~ /[A-Z]{4}/i) {
				complain(warning => "Unparseable date $date - often because the month name isn't 3 letters");
				return;
			}
			if(($date =~ /^\d/) && (my $d = date_parser_cached($date))) {
				return $dfn->parse_datetime($d->{'canonical'});
			}
			if(($date !~ /^(Abt|ca?)/i) && ($date =~ /^[\w\s]+$/)) {
				# ACOM exports full month names and non-standard format dates e.g. U.S. format MMM, DD YYYY
				if(my $rc = $dfn->parse_datetime($date)) {
					return $rc;
				}
				complain(warning => "Can't parse date '$date'");
			}
		}
	}
	undef;
}

sub descendents
{
	my $person = shift;

	my @list;
	if(my $l = shift) {
		@list = @{$l};
	}

	my @children = $person->children();
	if(scalar(@children)) {
		foreach my $child(@children) {
			push @list, $child;
			# my @spouses = $child->spouse();
			# if(scalar(@spouses)) {
				# push @list, @spouses;
			# }
			@list = descendents($child, \@list);
		}
	}

	return @list;
}

sub ancestors
{
	my $person = shift;

	my @list;
	if(my $l = shift) {
		@list = @{$l};
	}

	if(my $mother = $person->mother()) {
		push @list, $mother;
		@list = ancestors($mother, \@list);
		my @siblings = $mother->siblings();
		foreach my $sibling(@siblings) {
			push @list, $sibling;
			# my @spouses = $sibling->spouse();
			# if(scalar(@spouses)) {
				# push @list, @spouses;
			# }
			@list = descendents($sibling, \@list);
		}
	}
	if(my $father = $person->father()) {
		push @list, $father;
		@list = ancestors($father, \@list);
		my @siblings = $father->siblings();
		foreach my $sibling(@siblings) {
			push @list, $sibling;
			# my @spouses = $sibling->spouse();
			# if(scalar(@spouses)) {
				# push @list, @spouses;
			# }
			@list = descendents($sibling, \@list);
		}
	}

	return @list;
}

# Print the text in "string" to the "text" object returned from PDF::API2->text()
sub pdfprint
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $pdfpage = $params{'pdfpage'};

	die 'pdfprint: pdfpage is not optional' if(!defined($pdfpage));

	if($pdfpage->full()) {
		print "pdfprint: full returned true\n" if($opts{'v'});
		return 0;
	}

	my $indent = ($params{'noindent'}) ? '' : '    ';

	my @lines = split(/\n/, wrap($indent, '', ($params{'string'})));

	if(scalar(@lines) >= $pdfpage->linesleft() - 1) {
		print 'pdfprint: ', scalar(@lines), ' >= ', ($pdfpage->linesleft() - 1), "\n" if($opts{'v'});

		return 0;
	}

	my $text = $pdfpage->text();
	my $x = $params{'x'} || 40;

	foreach my $line (@lines) {
		$text->translate($x, $pdfpage->newline());
		if($params{'centre'}) {
			$text->text_center($line);
		} else {
			$text->text($line);
		}
	}
	return 1;
}

# Inspired by Tree::Family.  That module doesn't quite do what I want, so
# I've mercilessly re-used the ideas of what to do from it.
sub print_graphviz
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $fout = $params{'fout'};
	my $person = $params{'person'};
	my $colour = $params{'colour'};
	my $profile_image = $params{'profile_image'};

	if(!defined($colour)) {
		my $gender = get_value({ person => $person, value => 'sex' }) || $person->sex();
		if(defined($gender)) {
			$gender = $gender;
		} else {
			complain({ person => $person, warning => 'unknown sex' });
			$gender = 'M';	# Avoid "Use of uninitialized value" in Tree::Family
		}
		$colour = ($gender eq 'M' ? '#093AB5' : '#C666B8');
	}

	print $fout $person->xref(), ' [shape=box,fontsize="10",',
		"color=\"$colour\",";

	# if($params{'format'} eq 'dynamic') {
		# print $fout 'href="?page=people&entry=', $person->xref(), '",';
	# } else {
		# print $fout 'href="', make_filename_from_person(person => $person), '",';
	# }

	my $label = $person->as_string();
	my $dob = dateofbirth($person);
	my $dod = dateofdeath($person);

	my $thumbnail;

	# If you get 'Warning: No loadimage plugin for "jpeg:cairo"', do this
	# instead:
	# if(0) {
	if($profile_image && (defined($dod) || $opts{'l'})) {
		if(defined($dob)) {
			$dob .= "<TR><TD>b. $dob</TD></TR>";
		} else {
			$dob = '';
		}
		if(defined($dod)) {
			$dod .= "<TR><TD>d. $dod</TD></TR>";
		} else {
			$dod = '';
		}
		# Create a thumbnail
		my $image = Image::Magick->new();
		$image->read($profile_image);
		my ($thumb, $x, $y) = Image::Magick::Thumbnail::create($image, 100);
		my @thumbname = File::Basename::fileparse($profile_image);
		# use PNG to try to avoid
		#	'Warning: No loadimage plugin for "jpeg:cairo"'
		$thumbname[0] =~ s/\.jpg$/.png/;
		$thumbnail = "thumbs/$thumbname[0]";
		$thumb->Write($thumbnail);

		# FIXME: TABLE isn't supported by Graphviz
		print $fout "label=<<TABLE border=\"0\" cellborder=\"0\"><TR><TD><IMG SRC=\"thumbs/$thumbname[0]\" scale=\"true\"/></TD></TR><TR><TD>$label</TD></TR>$dob$dod</TABLE>>",
			",labelloc=b";

		# print $fout ",image=\"$profile_image\",labelloc=b";

		chmod 0444, $thumbnail;
	} elsif(defined($dod) || $opts{'l'}) {
		if(defined($dob)) {
			$label .= "\\nb. $dob";
		}
		if(defined($dod)) {
			$label .= "\\nd. $dod";
		}
		print $fout "label=\"$label\"";
	} else {
		print $fout "label=\"$label\"";
	}

	print $fout "];\n";

	return $thumbnail;
}

sub print_graphviz_generation
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $fout = $params{'fout'};
	my $person = $params{'person'};
	my $rank = $params{'rank'} + 1;
	my $maxrank = $params{'maxrank'} + 1;
	$params{'rank'} = $rank;

	return if($maxrank && ($rank >= $maxrank));

	print $fout "} subgraph children$rank { rank=\"$rank\"; ";
	print_graphviz({ person => $person, fout => $fout, format => 'dynamic' });

	if(($rank > 1) && (my $father = $person->father())) {
		print $fout $father->xref(), ' -> ', $person->xref(), ";\n";
	}

	if($person->sex() eq 'M') {
		# my @children = $person->children();
		my @children = map { $_->children() } $person->fams();
		if(scalar(@children) > 0) {
			# TODO: sort by date of birth
			foreach my $child(@children) {
				if($opts{'l'} || !is_alive(person => $child)) {
					$params{'person'} = $child;
					print_graphviz_generation(\%params);
				}
			}
		}
	}
}

sub get_all_residences
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'person'} = shift;
	}

	my $person = $params{'person'};

	die "Usage: get_all_residences(\$person')" unless($person);

	my @residences = $person->residence();
	my @rc;
	my $index = 0;
	foreach my $residence(@residences) {
		$index++;
		if(!ref($residence)) {
			my $r = $person->tag_record('RESI', $index);
			if(ref($r) eq 'Gedcom::Record') {
				$residence = $r;
			}
		}
		if(ref($residence) eq 'Gedcom::Record') {
			push @rc, $residence;
		}
	}
	my @events = $person->event();
	$index = 0;
	foreach my $event(@events) {
		$index++;
		if(!ref($event)) {
			my $e = $person->tag_record('EVEN', $index);
			if(ref($e) eq 'Gedcom::Record') {
				$event = $e;
			}
		}
		next if(ref($event) ne 'Gedcom::Record');
		my $type = $event->type();
		next if(!defined($type));
		# if(($type =~ /^Census U[KS] \d{4}$/) || ($type eq 'Register UK 1939') || ($type eq 'Hospitalisation')) {
		if(($type =~ /Census/) || ($type eq 'Register UK 1939') || ($type eq 'Hospitalisation') || ($type eq 'Story')) {
			push @rc, $event;
		}
	}
	my @censuses = $person->census();
	$index = 0;
	foreach my $census(@censuses) {
		$index++;
		if(!ref($census)) {
			my $c = $person->tag_record('CENS', $index);
			if(ref($c) eq 'Gedcom::Record') {
				$census = $c;
			}
		}
		if(ref($census) eq 'Gedcom::Record') {
			push @rc, $census;
		}
	}

	return @rc;
}

sub get_all_occupations
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'person'} = shift;
	}

	my $person = $params{'person'};

	die "Usage: get_all_occupations(\$person')" unless($person);

	my @occupations = get_value({ person => $person, value => 'occupation' });

	if((scalar(@occupations) == 1) && !defined($occupations[0])) {
		return;
	}

	while($occupations[0] && ($occupations[0] =~ /^scho(ol|lar)/i)) {
		shift @occupations;
	}
	while($occupations[0] && ($occupations[0] =~ /wife$/i)) {
		shift @occupations;
	}
	while($occupations[0] && ($occupations[0] =~ /unemployed/i)) {
		shift @occupations;
	}
	while($occupations[0] && ($occupations[0] =~ /Unpaid domestic duties/i)) {
		shift @occupations;
	}
	if(scalar(@occupations)) {
		if($occupations[0] =~ /works? on (.+)/i) {
			$occupations[0] = "$1 worker";
		} elsif(($occupations[0] eq 'Ag Lab') ||
			($occupations[0] eq 'Ag Labourer') ||
			($occupations[0] eq 'Ag Labourer Pauper') ||
			($occupations[0] eq 'Farm Labourer') ||
			($occupations[0] eq 'Agricultural Farm Labourer') ||
			($occupations[0] eq 'Ordinary Agricultural Labourer') ||
			($occupations[0] eq 'work on farm') ||
			($occupations[0] eq 'Labourer (Ag)')) {
			$occupations[0] = 'Agricultural Labourer';
		} elsif($occupations[0] eq 'Poultry Farming') {
			$occupations[0] = 'Poultry Farmer';
		} elsif($occupations[0] eq 'Platelayer Railway') {
			$occupations[0] = 'Railway Platelayer';
		} elsif($occupations[0] eq 'General Servant Domestic') {
			$occupations[0] = 'Domestic Servant';
		} elsif($occupations[0] eq 'Lorry Driver Heavy Worker') {
			$occupations[0] = 'Lorry Driver';
		} elsif($occupations[0] =~ /^Shop Assistant (.*)/) {
			$occupations[0] = "$1's Shop Assistant";
		} elsif($occupations[0] =~ /(.*) Assistant$/i) {
			$occupations[0] = "$1's Assistant" unless($1 =~ /'s$/);
		} elsif($occupations[0] =~ /Clerk (.*)/) {
			$occupations[0] = "$1 Clerk";
		} elsif($occupations[0] =~ /Salesman (.*)/i) {
			$occupations[0] = "$1 Salesman";
		} elsif($occupations[0] =~ /Foreman (.*)/i) {
			$occupations[0] = "$1 Foreman";
			$occupations[0] =~ s/^of the //i;
		} elsif($occupations[0] =~ /Labourer Gas Stoker/) {
			$occupations[0] = 'Gas Stoker';
		} elsif($occupations[0] eq 'Under Gardener Domestic') {
			$occupations[0] = 'Domestic Gardener';
		} elsif($occupations[0] eq "Brewer's Labourer") {
			$occupations[0] = 'Brewery Labourer';
		} elsif($occupations[0] eq 'Plate Glass Cutter') {
		} elsif($occupations[0] =~ /(.+)([a-z])s\s+([a-z]+)$/i) {
			# Don't change Bus Driver to Bu's Driver
			$occupations[0] = "$1$2's $3" unless(("$1$2" eq 'Bu') || ("$1$2" eq 'Harnes'));
		}
	}
	while(scalar(@occupations) > 1) {
		if(($occupations[0] =~ /^labou?rer/i) && ($occupations[1] =~ /^labou?rer/i)) {
			shift @occupations;
		} elsif(lc($occupations[0]) eq lc($occupations[1])) {
			shift @occupations;
		} else {
			last;
		}
	}

	if(scalar(@occupations)) {
		if($occupations[0]) {
			if($language eq 'English') {
				if($ENV{'LANG'} =~ /^en_US/) {
					$occupations[0] = Lingua::EN::ABC::b2a(lc($occupations[0]));
				} elsif($ENV{'LANG'} =~ /^en_CA/) {
					$occupations[0] = Lingua::EN::ABC::b2c(lc($occupations[0]));
				} else {
					$occupations[0] = Lingua::EN::ABC::a2b(lc($occupations[0]));
				}
			} elsif(($language eq 'French') && ($occupations[0] eq 'Postman')) {
				$occupations[0] = (($person->sex() eq 'M') ? 'Facteur' : 'Factrisse');
			}
			$occupations[0] =~ s/[\(\)]//g;
			$occupations[0] =~ s/\s+Own Account//i;
			if($occupations[0] =~ /works? (on|for) (.+)/i) {
				$occupations[0] = "$2 Worker";
			} elsif($occupations[0] =~ /^Cleaner\s+(.+)/i) {
				$occupations[0] = "$1 Cleaner";
			} else {
				$occupations[0] = ucfirst($occupations[0]);
			}
		} else {
			complain({
				person => $person,
				warning => 'Occupation is empty'
			});
			shift @occupations;
		}
	}

	return @occupations;
}

# Document a complete journey when both a departure and an arrival record exist
sub journey
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};
	my $arrival = $params{'arrival'};
	my $departure = $params{'departure'};

	my $rc;
	my $yod;
	my $yoa;
	my $dod = $departure->date();
	my $doa = $arrival->date();
	my $only_have_departure_year;

	if($doa && ($doa =~ /(\d{3,4})/)) {
		$yoa = $1;
		$doa =~ s/\s?\d{3,4}//;
		if($dod && ($dod =~ /(\d{3,4})/)) {
			$yod = $1;
			$dod =~ s/\s?\d{3,4}//;
			if($dod =~ /^\d/) {
				$dod = "on $dod";
			} else {
				$dod = "during $yod";
				$only_have_departure_year = 1;
			}
			if($doa =~ /^\d/) {
				$doa = "on $doa";
			} elsif($yoa == $yod) {
				$doa = 'later that same year';
			} else {
				$doa = "during $yoa";
			}
		}
	}
	$rc = $person->pronoun();
	if($language eq 'French') {
		$rc = ($rc eq 'He') ? 'Il' : 'Elle';
	}
	if($yoa || $yod) {
		my $year = $yoa // $yod;
		if($language eq 'French') {
			$rc = " En $year " . lc($rc);
		} else {
			$rc = " In $year " . lc($rc);
		}
	# } else {
		# $yod = year({ person => $person, record => $departure });
		# $yoa = year({ person => $person, record => $arrival });
	}

	if($language eq 'French') {
		$rc .= ' a voyagé';
	} elsif($ENV{'LANG'} =~ /^en_US/) {
		$rc .= ' traveled';
	} else {
		$rc .= ' travelled';
	}

	if(defined($departure->place())) {
		$rc .= (($language eq 'French') ? ' de' : ' from') . place({ person => $person, record => $departure, nopreposition => 1 });
		if(my $notes = notes(record => $departure)) {
			$notes = lcfirst($notes) unless($notes =~ /^[A-Z]{2}/);
			$notes =~ s/\.$//;
			$rc .= " ($notes)";
		}
	} else {
		complain({ person => $person, warning => 'Departure record has no location' });
	}
	if(defined($arrival->place())) {
		$rc .= (($language eq 'French') ? ' à' : ' to') . place({ person => $person, record => $arrival, nopreposition => 1 });
		if(my $notes = notes(record => $arrival)) {
			$notes = lcfirst($notes) unless($notes =~ /^[A-Z]{2}/);
			$notes =~ s/\.$//;
			$rc .= " ($notes)";
		}
	} else {
		complain({ person => $person, warning => 'Arrival record has no location' });
	}

	if(defined($dod) && !$only_have_departure_year) {
		return "$rc, departing $dod and";
	}

	return "$rc arriving $doa";
}

sub count_descendents_at_level
{
	my $person = shift;
	my $level = shift;

	my $count = 0;
	foreach my $child($person->children()) {
		if($level == 1) {
			$count++;
		} else {
			$count += count_descendents_at_level($child, $level - 1);
		}
	}
	return $count;
}

# Compare two dates. Approximate dates are compared.
# TODO: handle when only months are known
sub datecmp
{
	my ($left, $right) = @_;

	if((!defined($left)) || !defined($right)) {
		print STDERR "\n";
		if(!defined($left)) {
			print STDERR "BUG: left not defined\n";
		}
		if(!defined($right)) {
			print STDERR "BUG: right not defined\n";
		}
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		return 0;
	}
	if(!ref($left)) {
		if($left =~ /^(Abt|ca?)\s+(.+)/i) {
			$left = $2;
		}
		if($left !~ /^\d{3,4}$/) {
			my @l = $dfg->parse_datetime($left);
			my $rc = $l[1] || $l[0];
			if(!defined($rc)) {
				print STDERR "Date parse failure: ($left):\n";
				my $i = 0;
				while((my @call_details = caller($i++))) {
					print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
				}
				return 0;
			}
			$left = $rc;
		}
	}
	if(!ref($right)) {
		if($right =~ /^(Abt|ca?)\s+(.+)/i) {
			$right = $2;
		}
		if($right =~ /^\d{3,4}$/) {
			if(ref($left)) {
				return $left->year() <=> $right;
			} else {
				return $left <=> $right;
			}
		}
		# if(!$dfg->parse_datetime($right)) {
			# my $i = 0;
			# while((my @call_details = caller($i++))) {
				# print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
			# }
			# die join('<=>', @_);
		# }
		my @r = $dfg->parse_datetime($right);
		$right = $r[0];
	}
	if((!ref($left)) && ref($right)) {
		return $left <=> $right->year();
	}
	if(ref($left) && (!ref($right))) {
		return $left->year() <=> $right;
	}

	return $left <=> $right;
}

sub chronicling_america
{
	my ($person, $chronicling_params) = @_;

	return unless($opts{'w'});

	if(!defined($chronicling_params->{'firstname'})) {
		my $i = 0;
		while((my @call_details = (caller($i++)))) {
			print STDERR "\t", $call_details[1], ':', $call_details[2], ' calling function ', $call_details[3], "\n";
		}
		die $person->as_string(), ': BUG: no first name given';
	}
	if(length($chronicling_params->{'state'}) <= 2) {
		my $i = 0;
		while((my @call_details = (caller($i++)))) {
			print STDERR "\t", $call_details[1], ':', $call_details[2], ' calling function ', $call_details[3], "\n";
		}
		die $person->as_string(), ': BUG: state "', $chronicling_params->{'state'}, '" too short';
	}

	if(my $loc = Genealogy::ChroniclingAmerica->new($chronicling_params)) {
		while(my $url = $loc->get_next_entry()) {
			if($language eq 'French') {
				complain({ person => $person, warning => "Visitez $url" });
			} else {
				complain({ person => $person, warning => "Check out $url" });
			}
		}
	}
}

# FIXME: once RT127603 has been fixed
sub Geo::Coder::PlaceFinder::ua
{
	my $self = shift;

	if(my $ua = shift) {
		return $self->{_ua} = $ua;
	}

	return $self->{_ua};
}

# See https://github.com/OpenCageData/perl-Geo-Coder-OpenCage/issues/8
sub Geo::Coder::OpenCage::ua {
	my $self = shift;

	# if(my $ua = shift) {
		# $self->{ua} = $ua;
	# }
	return $self->{ua};
}

sub add_to_ical {
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $datetime = $params{'datetime'};

	my $event = Data::ICal::Entry::Event->new();

	$event->start($datetime);
	$event->all_day(1);
	$event->add_properties(summary => $params{'summary'});

	$params{'ical'}->add_entry($event);
}

sub dateofbirth {
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'person'} = shift;
	}

	my $person = $params{'person'};

	my $dateofbirth = get_value({ person => $person, value => 'birth date' });
	if((!defined($dateofbirth)) && (my $birth = $person->get_record('birth'))) {
		return $birth->date();
	}
	if(defined($dateofbirth) && (lc($dateofbirth) eq 'unknown')) {
		return;
	}
	return $dateofbirth;
}

sub dateofdeath {
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'person'} = shift;
	}

	my $person = $params{'person'};

	my $dateofdeath = get_value({ person => $person, value => 'death date' });
	if((!defined($dateofdeath)) && (my $death = $person->get_record('death'))) {
		return $death->date();
	}
	if(defined($dateofdeath) && (lc($dateofdeath) eq 'unknown')) {
		return;
	}
	return $dateofdeath;
}

1;

package PDFPage;

our $pixelsperline = 16;	# point size 12

sub new
{
	my $class = shift;

	$pixelsperline = 16;

	return bless { y => 750, page => $pdf->page() }, $class;
}

sub newline
{
	my $self = shift;

	$self->{'y'} -= $pixelsperline;

	if($self->{'y'} <= 10) {
		my $i = 0;
		while((my @call_details = (caller($i++)))) {
			print STDERR "\t", $call_details[1], ':', $call_details[2], ' calling function ', $call_details[3], "\n";
		}
		die 'BUG: fallen too low vertically; y = ', $self->{'y'};
	}

	return $self->{'y'};
}

sub full
{
	my $self = shift;

	return $self->{'y'} <= $pixelsperline * 2;
}

sub linesleft
{
	my $self = shift;

	return ($self->{'y'} / $pixelsperline) - 1;	# round fractions down
}

sub y
{
	my $self = shift;
	my $y = shift;

	if($y) {
		if($y <= 10) {
			my $i = 0;
			while((my @call_details = (caller($i++)))) {
				print STDERR "\t", $call_details[1], ':', $call_details[2], ' calling function ', $call_details[3], "\n";
			}
			die "BUG: fallen too low vertically; y = $y";
		}

		$self->{'y'} = $y;
	}

	return $self->{'y'};
}

sub page
{
	my $self = shift;

	return $self->{'page'};
}

sub text
{
	my $self = shift;

	if(!defined($self->{'text'})) {
		my $text = $self->{'text'} = $self->{'page'}->text();
		$text->textstart();
	}
	return $self->{'text'};
}

sub DESTROY {
	if(defined($^V) && ($^V ge 'v5.14.0')) {
		return if ${^GLOBAL_PHASE} eq 'DESTRUCT';	# >= 5.14.0 only
	}
	my $self = shift;

	if($self->{'text'}) {
		$self->{'text'}->textend();
	}
}
# TODO: DESTROY - add a page number
